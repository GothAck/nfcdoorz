// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_IPCPOLICY_NFCDOORZ_IPC_POLICY_H_
#define FLATBUFFERS_GENERATED_IPCPOLICY_NFCDOORZ_IPC_POLICY_H_

#include "flatbuffers/flatbuffers.h"

namespace nfcdoorz {
namespace ipc {
namespace policy {

struct TestCall;
struct TestCallT;

struct TestReply;
struct TestReplyT;

struct RequestEvent;
struct RequestEventT;

struct Call;
struct CallT;

struct Reply;
struct ReplyT;

struct Server;
struct ServerT;

inline const flatbuffers::TypeTable *TestCallTypeTable();

inline const flatbuffers::TypeTable *TestReplyTypeTable();

inline const flatbuffers::TypeTable *RequestEventTypeTable();

inline const flatbuffers::TypeTable *CallTypeTable();

inline const flatbuffers::TypeTable *ReplyTypeTable();

inline const flatbuffers::TypeTable *ServerTypeTable();

enum class Calls : uint8_t {
  NONE = 0,
  TestCall = 1,
  MIN = NONE,
  MAX = TestCall
};

inline const Calls (&EnumValuesCalls())[2] {
  static const Calls values[] = {
    Calls::NONE,
    Calls::TestCall
  };
  return values;
}

inline const char * const *EnumNamesCalls() {
  static const char * const names[] = {
    "NONE",
    "TestCall",
    nullptr
  };
  return names;
}

inline const char *EnumNameCalls(Calls e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCalls()[index];
}

template<typename T> struct CallsTraits {
  static const Calls enum_value = Calls::NONE;
};

template<> struct CallsTraits<TestCall> {
  static const Calls enum_value = Calls::TestCall;
};

struct CallsUnion {
  Calls type;
  void *value;

  CallsUnion() : type(Calls::NONE), value(nullptr) {}
  CallsUnion(CallsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Calls::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  CallsUnion(const CallsUnion &) FLATBUFFERS_NOEXCEPT;
  CallsUnion &operator=(const CallsUnion &u) FLATBUFFERS_NOEXCEPT
    { CallsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  CallsUnion &operator=(CallsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~CallsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = CallsTraits<typename T::TableType>::enum_value;
    if (type != Calls::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Calls type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  TestCallT *AsTestCall() {
    return type == Calls::TestCall ?
      reinterpret_cast<TestCallT *>(value) : nullptr;
  }
  const TestCallT *AsTestCall() const {
    return type == Calls::TestCall ?
      reinterpret_cast<const TestCallT *>(value) : nullptr;
  }
};

bool VerifyCalls(flatbuffers::Verifier &verifier, const void *obj, Calls type);
bool VerifyCallsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class Replies : uint8_t {
  NONE = 0,
  TestReply = 1,
  MIN = NONE,
  MAX = TestReply
};

inline const Replies (&EnumValuesReplies())[2] {
  static const Replies values[] = {
    Replies::NONE,
    Replies::TestReply
  };
  return values;
}

inline const char * const *EnumNamesReplies() {
  static const char * const names[] = {
    "NONE",
    "TestReply",
    nullptr
  };
  return names;
}

inline const char *EnumNameReplies(Replies e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesReplies()[index];
}

template<typename T> struct RepliesTraits {
  static const Replies enum_value = Replies::NONE;
};

template<> struct RepliesTraits<TestReply> {
  static const Replies enum_value = Replies::TestReply;
};

struct RepliesUnion {
  Replies type;
  void *value;

  RepliesUnion() : type(Replies::NONE), value(nullptr) {}
  RepliesUnion(RepliesUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Replies::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  RepliesUnion(const RepliesUnion &) FLATBUFFERS_NOEXCEPT;
  RepliesUnion &operator=(const RepliesUnion &u) FLATBUFFERS_NOEXCEPT
    { RepliesUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  RepliesUnion &operator=(RepliesUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~RepliesUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = RepliesTraits<typename T::TableType>::enum_value;
    if (type != Replies::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Replies type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  TestReplyT *AsTestReply() {
    return type == Replies::TestReply ?
      reinterpret_cast<TestReplyT *>(value) : nullptr;
  }
  const TestReplyT *AsTestReply() const {
    return type == Replies::TestReply ?
      reinterpret_cast<const TestReplyT *>(value) : nullptr;
  }
};

bool VerifyReplies(flatbuffers::Verifier &verifier, const void *obj, Replies type);
bool VerifyRepliesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class Events : uint8_t {
  NONE = 0,
  RequestEvent = 1,
  MIN = NONE,
  MAX = RequestEvent
};

inline const Events (&EnumValuesEvents())[2] {
  static const Events values[] = {
    Events::NONE,
    Events::RequestEvent
  };
  return values;
}

inline const char * const *EnumNamesEvents() {
  static const char * const names[] = {
    "NONE",
    "RequestEvent",
    nullptr
  };
  return names;
}

inline const char *EnumNameEvents(Events e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEvents()[index];
}

template<typename T> struct EventsTraits {
  static const Events enum_value = Events::NONE;
};

template<> struct EventsTraits<RequestEvent> {
  static const Events enum_value = Events::RequestEvent;
};

struct EventsUnion {
  Events type;
  void *value;

  EventsUnion() : type(Events::NONE), value(nullptr) {}
  EventsUnion(EventsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Events::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  EventsUnion(const EventsUnion &) FLATBUFFERS_NOEXCEPT;
  EventsUnion &operator=(const EventsUnion &u) FLATBUFFERS_NOEXCEPT
    { EventsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  EventsUnion &operator=(EventsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~EventsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = EventsTraits<typename T::TableType>::enum_value;
    if (type != Events::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Events type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  RequestEventT *AsRequestEvent() {
    return type == Events::RequestEvent ?
      reinterpret_cast<RequestEventT *>(value) : nullptr;
  }
  const RequestEventT *AsRequestEvent() const {
    return type == Events::RequestEvent ?
      reinterpret_cast<const RequestEventT *>(value) : nullptr;
  }
};

bool VerifyEvents(flatbuffers::Verifier &verifier, const void *obj, Events type);
bool VerifyEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct TestCallT : public flatbuffers::NativeTable {
  typedef TestCall TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.TestCallT";
  }
  TestCallT() {
  }
};

struct TestCall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TestCallT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TestCallTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.TestCall";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TestCallT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TestCallT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TestCall> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TestCallT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TestCallBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TestCallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TestCallBuilder &operator=(const TestCallBuilder &);
  flatbuffers::Offset<TestCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TestCall>(end);
    return o;
  }
};

inline flatbuffers::Offset<TestCall> CreateTestCall(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TestCallBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TestCall> CreateTestCall(flatbuffers::FlatBufferBuilder &_fbb, const TestCallT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TestReplyT : public flatbuffers::NativeTable {
  typedef TestReply TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.TestReplyT";
  }
  TestReplyT() {
  }
};

struct TestReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TestReplyT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TestReplyTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.TestReply";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TestReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TestReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TestReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TestReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TestReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TestReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TestReplyBuilder &operator=(const TestReplyBuilder &);
  flatbuffers::Offset<TestReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TestReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<TestReply> CreateTestReply(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TestReplyBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TestReply> CreateTestReply(flatbuffers::FlatBufferBuilder &_fbb, const TestReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RequestEventT : public flatbuffers::NativeTable {
  typedef RequestEvent TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.RequestEventT";
  }
  std::string deviceID;
  std::vector<uint8_t> cardUID;
  RequestEventT() {
  }
};

struct RequestEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RequestEventT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RequestEventTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.RequestEvent";
  }
  enum {
    VT_DEVICEID = 4,
    VT_CARDUID = 6
  };
  const flatbuffers::String *deviceID() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::Vector<uint8_t> *cardUID() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CARDUID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.VerifyString(deviceID()) &&
           VerifyOffset(verifier, VT_CARDUID) &&
           verifier.VerifyVector(cardUID()) &&
           verifier.EndTable();
  }
  RequestEventT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RequestEventT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RequestEvent> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestEventT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RequestEventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deviceID(flatbuffers::Offset<flatbuffers::String> deviceID) {
    fbb_.AddOffset(RequestEvent::VT_DEVICEID, deviceID);
  }
  void add_cardUID(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> cardUID) {
    fbb_.AddOffset(RequestEvent::VT_CARDUID, cardUID);
  }
  explicit RequestEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestEventBuilder &operator=(const RequestEventBuilder &);
  flatbuffers::Offset<RequestEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RequestEvent>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequestEvent> CreateRequestEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> deviceID = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> cardUID = 0) {
  RequestEventBuilder builder_(_fbb);
  builder_.add_cardUID(cardUID);
  builder_.add_deviceID(deviceID);
  return builder_.Finish();
}

inline flatbuffers::Offset<RequestEvent> CreateRequestEventDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *deviceID = nullptr,
    const std::vector<uint8_t> *cardUID = nullptr) {
  return nfcdoorz::ipc::policy::CreateRequestEvent(
      _fbb,
      deviceID ? _fbb.CreateString(deviceID) : 0,
      cardUID ? _fbb.CreateVector<uint8_t>(*cardUID) : 0);
}

flatbuffers::Offset<RequestEvent> CreateRequestEvent(flatbuffers::FlatBufferBuilder &_fbb, const RequestEventT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CallT : public flatbuffers::NativeTable {
  typedef Call TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.CallT";
  }
  uint64_t id;
  CallsUnion msg;
  CallT()
      : id(0) {
  }
};

struct Call FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CallT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CallTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.Call";
  }
  enum {
    VT_ID = 4,
    VT_MSG_TYPE = 6,
    VT_MSG = 8
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  Calls msg_type() const {
    return static_cast<Calls>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const TestCall *msg_as_TestCall() const {
    return msg_type() == Calls::TestCall ? static_cast<const TestCall *>(msg()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyCalls(verifier, msg(), msg_type()) &&
           verifier.EndTable();
  }
  CallT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CallT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Call> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const TestCall *Call::msg_as<TestCall>() const {
  return msg_as_TestCall();
}

struct CallBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Call::VT_ID, id, 0);
  }
  void add_msg_type(Calls msg_type) {
    fbb_.AddElement<uint8_t>(Call::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(Call::VT_MSG, msg);
  }
  explicit CallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallBuilder &operator=(const CallBuilder &);
  flatbuffers::Offset<Call> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Call>(end);
    return o;
  }
};

inline flatbuffers::Offset<Call> CreateCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    Calls msg_type = Calls::NONE,
    flatbuffers::Offset<void> msg = 0) {
  CallBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

flatbuffers::Offset<Call> CreateCall(flatbuffers::FlatBufferBuilder &_fbb, const CallT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReplyT : public flatbuffers::NativeTable {
  typedef Reply TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.ReplyT";
  }
  uint64_t id;
  RepliesUnion msg;
  EventsUnion event;
  ReplyT()
      : id(0) {
  }
};

struct Reply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReplyT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReplyTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.Reply";
  }
  enum {
    VT_ID = 4,
    VT_MSG_TYPE = 6,
    VT_MSG = 8,
    VT_EVENT_TYPE = 10,
    VT_EVENT = 12
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  Replies msg_type() const {
    return static_cast<Replies>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const TestReply *msg_as_TestReply() const {
    return msg_type() == Replies::TestReply ? static_cast<const TestReply *>(msg()) : nullptr;
  }
  Events event_type() const {
    return static_cast<Events>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  template<typename T> const T *event_as() const;
  const RequestEvent *event_as_RequestEvent() const {
    return event_type() == Events::RequestEvent ? static_cast<const RequestEvent *>(event()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyReplies(verifier, msg(), msg_type()) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE) &&
           VerifyOffset(verifier, VT_EVENT) &&
           VerifyEvents(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
  ReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const TestReply *Reply::msg_as<TestReply>() const {
  return msg_as_TestReply();
}

template<> inline const RequestEvent *Reply::event_as<RequestEvent>() const {
  return event_as_RequestEvent();
}

struct ReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Reply::VT_ID, id, 0);
  }
  void add_msg_type(Replies msg_type) {
    fbb_.AddElement<uint8_t>(Reply::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(Reply::VT_MSG, msg);
  }
  void add_event_type(Events event_type) {
    fbb_.AddElement<uint8_t>(Reply::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(flatbuffers::Offset<void> event) {
    fbb_.AddOffset(Reply::VT_EVENT, event);
  }
  explicit ReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReplyBuilder &operator=(const ReplyBuilder &);
  flatbuffers::Offset<Reply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reply>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply> CreateReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    Replies msg_type = Replies::NONE,
    flatbuffers::Offset<void> msg = 0,
    Events event_type = Events::NONE,
    flatbuffers::Offset<void> event = 0) {
  ReplyBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_event(event);
  builder_.add_msg(msg);
  builder_.add_event_type(event_type);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

flatbuffers::Offset<Reply> CreateReply(flatbuffers::FlatBufferBuilder &_fbb, const ReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ServerT : public flatbuffers::NativeTable {
  typedef Server TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.ServerT";
  }
  std::unique_ptr<CallT> call;
  std::unique_ptr<ReplyT> reply;
  ServerT() {
  }
};

struct Server FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ServerTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.Server";
  }
  enum {
    VT_CALL = 4,
    VT_REPLY = 6
  };
  const Call *call() const {
    return GetPointer<const Call *>(VT_CALL);
  }
  const Reply *reply() const {
    return GetPointer<const Reply *>(VT_REPLY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CALL) &&
           verifier.VerifyTable(call()) &&
           VerifyOffset(verifier, VT_REPLY) &&
           verifier.VerifyTable(reply()) &&
           verifier.EndTable();
  }
  ServerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ServerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Server> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ServerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_call(flatbuffers::Offset<Call> call) {
    fbb_.AddOffset(Server::VT_CALL, call);
  }
  void add_reply(flatbuffers::Offset<Reply> reply) {
    fbb_.AddOffset(Server::VT_REPLY, reply);
  }
  explicit ServerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerBuilder &operator=(const ServerBuilder &);
  flatbuffers::Offset<Server> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Server>(end);
    return o;
  }
};

inline flatbuffers::Offset<Server> CreateServer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Call> call = 0,
    flatbuffers::Offset<Reply> reply = 0) {
  ServerBuilder builder_(_fbb);
  builder_.add_reply(reply);
  builder_.add_call(call);
  return builder_.Finish();
}

flatbuffers::Offset<Server> CreateServer(flatbuffers::FlatBufferBuilder &_fbb, const ServerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TestCallT *TestCall::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TestCallT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TestCall::UnPackTo(TestCallT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TestCall> TestCall::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TestCallT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTestCall(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TestCall> CreateTestCall(flatbuffers::FlatBufferBuilder &_fbb, const TestCallT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TestCallT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return nfcdoorz::ipc::policy::CreateTestCall(
      _fbb);
}

inline TestReplyT *TestReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TestReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TestReply::UnPackTo(TestReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TestReply> TestReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TestReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTestReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TestReply> CreateTestReply(flatbuffers::FlatBufferBuilder &_fbb, const TestReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TestReplyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return nfcdoorz::ipc::policy::CreateTestReply(
      _fbb);
}

inline RequestEventT *RequestEvent::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RequestEventT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RequestEvent::UnPackTo(RequestEventT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = deviceID(); if (_e) _o->deviceID = _e->str(); };
  { auto _e = cardUID(); if (_e) { _o->cardUID.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cardUID[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<RequestEvent> RequestEvent::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestEventT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequestEvent(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RequestEvent> CreateRequestEvent(flatbuffers::FlatBufferBuilder &_fbb, const RequestEventT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RequestEventT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _deviceID = _o->deviceID.empty() ? 0 : _fbb.CreateString(_o->deviceID);
  auto _cardUID = _o->cardUID.size() ? _fbb.CreateVector(_o->cardUID) : 0;
  return nfcdoorz::ipc::policy::CreateRequestEvent(
      _fbb,
      _deviceID,
      _cardUID);
}

inline CallT *Call::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CallT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Call::UnPackTo(CallT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = msg_type(); _o->msg.type = _e; };
  { auto _e = msg(); if (_e) _o->msg.value = CallsUnion::UnPack(_e, msg_type(), _resolver); };
}

inline flatbuffers::Offset<Call> Call::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCall(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Call> CreateCall(flatbuffers::FlatBufferBuilder &_fbb, const CallT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CallT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _msg_type = _o->msg.type;
  auto _msg = _o->msg.Pack(_fbb);
  return nfcdoorz::ipc::policy::CreateCall(
      _fbb,
      _id,
      _msg_type,
      _msg);
}

inline ReplyT *Reply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply::UnPackTo(ReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = msg_type(); _o->msg.type = _e; };
  { auto _e = msg(); if (_e) _o->msg.value = RepliesUnion::UnPack(_e, msg_type(), _resolver); };
  { auto _e = event_type(); _o->event.type = _e; };
  { auto _e = event(); if (_e) _o->event.value = EventsUnion::UnPack(_e, event_type(), _resolver); };
}

inline flatbuffers::Offset<Reply> Reply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply> CreateReply(flatbuffers::FlatBufferBuilder &_fbb, const ReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReplyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _msg_type = _o->msg.type;
  auto _msg = _o->msg.Pack(_fbb);
  auto _event_type = _o->event.type;
  auto _event = _o->event.Pack(_fbb);
  return nfcdoorz::ipc::policy::CreateReply(
      _fbb,
      _id,
      _msg_type,
      _msg,
      _event_type,
      _event);
}

inline ServerT *Server::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ServerT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Server::UnPackTo(ServerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = call(); if (_e) _o->call = std::unique_ptr<CallT>(_e->UnPack(_resolver)); };
  { auto _e = reply(); if (_e) _o->reply = std::unique_ptr<ReplyT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Server> Server::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateServer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Server> CreateServer(flatbuffers::FlatBufferBuilder &_fbb, const ServerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ServerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _call = _o->call ? CreateCall(_fbb, _o->call.get(), _rehasher) : 0;
  auto _reply = _o->reply ? CreateReply(_fbb, _o->reply.get(), _rehasher) : 0;
  return nfcdoorz::ipc::policy::CreateServer(
      _fbb,
      _call,
      _reply);
}

inline bool VerifyCalls(flatbuffers::Verifier &verifier, const void *obj, Calls type) {
  switch (type) {
    case Calls::NONE: {
      return true;
    }
    case Calls::TestCall: {
      auto ptr = reinterpret_cast<const TestCall *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyCallsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCalls(
        verifier,  values->Get(i), types->GetEnum<Calls>(i))) {
      return false;
    }
  }
  return true;
}

inline void *CallsUnion::UnPack(const void *obj, Calls type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Calls::TestCall: {
      auto ptr = reinterpret_cast<const TestCall *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> CallsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Calls::TestCall: {
      auto ptr = reinterpret_cast<const TestCallT *>(value);
      return CreateTestCall(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline CallsUnion::CallsUnion(const CallsUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case Calls::TestCall: {
      value = new TestCallT(*reinterpret_cast<TestCallT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void CallsUnion::Reset() {
  switch (type) {
    case Calls::TestCall: {
      auto ptr = reinterpret_cast<TestCallT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Calls::NONE;
}

inline bool VerifyReplies(flatbuffers::Verifier &verifier, const void *obj, Replies type) {
  switch (type) {
    case Replies::NONE: {
      return true;
    }
    case Replies::TestReply: {
      auto ptr = reinterpret_cast<const TestReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyRepliesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyReplies(
        verifier,  values->Get(i), types->GetEnum<Replies>(i))) {
      return false;
    }
  }
  return true;
}

inline void *RepliesUnion::UnPack(const void *obj, Replies type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Replies::TestReply: {
      auto ptr = reinterpret_cast<const TestReply *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> RepliesUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Replies::TestReply: {
      auto ptr = reinterpret_cast<const TestReplyT *>(value);
      return CreateTestReply(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline RepliesUnion::RepliesUnion(const RepliesUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case Replies::TestReply: {
      value = new TestReplyT(*reinterpret_cast<TestReplyT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void RepliesUnion::Reset() {
  switch (type) {
    case Replies::TestReply: {
      auto ptr = reinterpret_cast<TestReplyT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Replies::NONE;
}

inline bool VerifyEvents(flatbuffers::Verifier &verifier, const void *obj, Events type) {
  switch (type) {
    case Events::NONE: {
      return true;
    }
    case Events::RequestEvent: {
      auto ptr = reinterpret_cast<const RequestEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEvents(
        verifier,  values->Get(i), types->GetEnum<Events>(i))) {
      return false;
    }
  }
  return true;
}

inline void *EventsUnion::UnPack(const void *obj, Events type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Events::RequestEvent: {
      auto ptr = reinterpret_cast<const RequestEvent *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> EventsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Events::RequestEvent: {
      auto ptr = reinterpret_cast<const RequestEventT *>(value);
      return CreateRequestEvent(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline EventsUnion::EventsUnion(const EventsUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case Events::RequestEvent: {
      value = new RequestEventT(*reinterpret_cast<RequestEventT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void EventsUnion::Reset() {
  switch (type) {
    case Events::RequestEvent: {
      auto ptr = reinterpret_cast<RequestEventT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Events::NONE;
}

inline const flatbuffers::TypeTable *CallsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TestCallTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "TestCall"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RepliesTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TestReplyTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "TestReply"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EventsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    RequestEventTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "RequestEvent"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TestCallTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TestReplyTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RequestEventTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const char * const names[] = {
    "deviceID",
    "cardUID"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CallTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    CallsTypeTable
  };
  static const char * const names[] = {
    "id",
    "msg_type",
    "msg"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReplyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_UTYPE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    RepliesTypeTable,
    EventsTypeTable
  };
  static const char * const names[] = {
    "id",
    "msg_type",
    "msg",
    "event_type",
    "event"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ServerTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    CallTypeTable,
    ReplyTypeTable
  };
  static const char * const names[] = {
    "call",
    "reply"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

}  // namespace policy
}  // namespace ipc
}  // namespace nfcdoorz

#endif  // FLATBUFFERS_GENERATED_IPCPOLICY_NFCDOORZ_IPC_POLICY_H_
