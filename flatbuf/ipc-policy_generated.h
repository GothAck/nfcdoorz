// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_IPCPOLICY_NFCDOORZ_IPC_POLICY_H_
#define FLATBUFFERS_GENERATED_IPCPOLICY_NFCDOORZ_IPC_POLICY_H_

#include "flatbuffers/flatbuffers.h"

namespace nfcdoorz {
namespace ipc {
namespace policy {

struct TestCall;
struct TestCallT;

struct TestReply;
struct TestReplyT;

struct PolicyRequestEvent;
struct PolicyRequestEventT;

struct PolicyCall;
struct PolicyCallT;

struct PolicyReply;
struct PolicyReplyT;

struct Server;
struct ServerT;

inline const flatbuffers::TypeTable *TestCallTypeTable();

inline const flatbuffers::TypeTable *TestReplyTypeTable();

inline const flatbuffers::TypeTable *PolicyRequestEventTypeTable();

inline const flatbuffers::TypeTable *PolicyCallTypeTable();

inline const flatbuffers::TypeTable *PolicyReplyTypeTable();

inline const flatbuffers::TypeTable *ServerTypeTable();

enum class PolicyCalls : uint8_t {
  NONE = 0,
  TestCall = 1,
  MIN = NONE,
  MAX = TestCall
};

inline const PolicyCalls (&EnumValuesPolicyCalls())[2] {
  static const PolicyCalls values[] = {
    PolicyCalls::NONE,
    PolicyCalls::TestCall
  };
  return values;
}

inline const char * const *EnumNamesPolicyCalls() {
  static const char * const names[] = {
    "NONE",
    "TestCall",
    nullptr
  };
  return names;
}

inline const char *EnumNamePolicyCalls(PolicyCalls e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPolicyCalls()[index];
}

template<typename T> struct PolicyCallsTraits {
  static const PolicyCalls enum_value = PolicyCalls::NONE;
};

template<> struct PolicyCallsTraits<TestCall> {
  static const PolicyCalls enum_value = PolicyCalls::TestCall;
};

struct PolicyCallsUnion {
  PolicyCalls type;
  void *value;

  PolicyCallsUnion() : type(PolicyCalls::NONE), value(nullptr) {}
  PolicyCallsUnion(PolicyCallsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(PolicyCalls::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  PolicyCallsUnion(const PolicyCallsUnion &) FLATBUFFERS_NOEXCEPT;
  PolicyCallsUnion &operator=(const PolicyCallsUnion &u) FLATBUFFERS_NOEXCEPT
    { PolicyCallsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  PolicyCallsUnion &operator=(PolicyCallsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~PolicyCallsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = PolicyCallsTraits<typename T::TableType>::enum_value;
    if (type != PolicyCalls::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, PolicyCalls type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  TestCallT *AsTestCall() {
    return type == PolicyCalls::TestCall ?
      reinterpret_cast<TestCallT *>(value) : nullptr;
  }
  const TestCallT *AsTestCall() const {
    return type == PolicyCalls::TestCall ?
      reinterpret_cast<const TestCallT *>(value) : nullptr;
  }
};

bool VerifyPolicyCalls(flatbuffers::Verifier &verifier, const void *obj, PolicyCalls type);
bool VerifyPolicyCallsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class PolicyReplies : uint8_t {
  NONE = 0,
  TestReply = 1,
  MIN = NONE,
  MAX = TestReply
};

inline const PolicyReplies (&EnumValuesPolicyReplies())[2] {
  static const PolicyReplies values[] = {
    PolicyReplies::NONE,
    PolicyReplies::TestReply
  };
  return values;
}

inline const char * const *EnumNamesPolicyReplies() {
  static const char * const names[] = {
    "NONE",
    "TestReply",
    nullptr
  };
  return names;
}

inline const char *EnumNamePolicyReplies(PolicyReplies e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPolicyReplies()[index];
}

template<typename T> struct PolicyRepliesTraits {
  static const PolicyReplies enum_value = PolicyReplies::NONE;
};

template<> struct PolicyRepliesTraits<TestReply> {
  static const PolicyReplies enum_value = PolicyReplies::TestReply;
};

struct PolicyRepliesUnion {
  PolicyReplies type;
  void *value;

  PolicyRepliesUnion() : type(PolicyReplies::NONE), value(nullptr) {}
  PolicyRepliesUnion(PolicyRepliesUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(PolicyReplies::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  PolicyRepliesUnion(const PolicyRepliesUnion &) FLATBUFFERS_NOEXCEPT;
  PolicyRepliesUnion &operator=(const PolicyRepliesUnion &u) FLATBUFFERS_NOEXCEPT
    { PolicyRepliesUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  PolicyRepliesUnion &operator=(PolicyRepliesUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~PolicyRepliesUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = PolicyRepliesTraits<typename T::TableType>::enum_value;
    if (type != PolicyReplies::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, PolicyReplies type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  TestReplyT *AsTestReply() {
    return type == PolicyReplies::TestReply ?
      reinterpret_cast<TestReplyT *>(value) : nullptr;
  }
  const TestReplyT *AsTestReply() const {
    return type == PolicyReplies::TestReply ?
      reinterpret_cast<const TestReplyT *>(value) : nullptr;
  }
};

bool VerifyPolicyReplies(flatbuffers::Verifier &verifier, const void *obj, PolicyReplies type);
bool VerifyPolicyRepliesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class PolicyEvents : uint8_t {
  NONE = 0,
  PolicyRequestEvent = 1,
  MIN = NONE,
  MAX = PolicyRequestEvent
};

inline const PolicyEvents (&EnumValuesPolicyEvents())[2] {
  static const PolicyEvents values[] = {
    PolicyEvents::NONE,
    PolicyEvents::PolicyRequestEvent
  };
  return values;
}

inline const char * const *EnumNamesPolicyEvents() {
  static const char * const names[] = {
    "NONE",
    "PolicyRequestEvent",
    nullptr
  };
  return names;
}

inline const char *EnumNamePolicyEvents(PolicyEvents e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPolicyEvents()[index];
}

template<typename T> struct PolicyEventsTraits {
  static const PolicyEvents enum_value = PolicyEvents::NONE;
};

template<> struct PolicyEventsTraits<PolicyRequestEvent> {
  static const PolicyEvents enum_value = PolicyEvents::PolicyRequestEvent;
};

struct PolicyEventsUnion {
  PolicyEvents type;
  void *value;

  PolicyEventsUnion() : type(PolicyEvents::NONE), value(nullptr) {}
  PolicyEventsUnion(PolicyEventsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(PolicyEvents::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  PolicyEventsUnion(const PolicyEventsUnion &) FLATBUFFERS_NOEXCEPT;
  PolicyEventsUnion &operator=(const PolicyEventsUnion &u) FLATBUFFERS_NOEXCEPT
    { PolicyEventsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  PolicyEventsUnion &operator=(PolicyEventsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~PolicyEventsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = PolicyEventsTraits<typename T::TableType>::enum_value;
    if (type != PolicyEvents::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, PolicyEvents type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  PolicyRequestEventT *AsPolicyRequestEvent() {
    return type == PolicyEvents::PolicyRequestEvent ?
      reinterpret_cast<PolicyRequestEventT *>(value) : nullptr;
  }
  const PolicyRequestEventT *AsPolicyRequestEvent() const {
    return type == PolicyEvents::PolicyRequestEvent ?
      reinterpret_cast<const PolicyRequestEventT *>(value) : nullptr;
  }
};

bool VerifyPolicyEvents(flatbuffers::Verifier &verifier, const void *obj, PolicyEvents type);
bool VerifyPolicyEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct TestCallT : public flatbuffers::NativeTable {
  typedef TestCall TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.TestCallT";
  }
  TestCallT() {
  }
};

struct TestCall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TestCallT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TestCallTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.TestCall";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TestCallT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TestCallT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TestCall> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TestCallT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TestCallBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TestCallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TestCallBuilder &operator=(const TestCallBuilder &);
  flatbuffers::Offset<TestCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TestCall>(end);
    return o;
  }
};

inline flatbuffers::Offset<TestCall> CreateTestCall(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TestCallBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TestCall> CreateTestCall(flatbuffers::FlatBufferBuilder &_fbb, const TestCallT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TestReplyT : public flatbuffers::NativeTable {
  typedef TestReply TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.TestReplyT";
  }
  TestReplyT() {
  }
};

struct TestReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TestReplyT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TestReplyTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.TestReply";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TestReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TestReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TestReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TestReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TestReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TestReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TestReplyBuilder &operator=(const TestReplyBuilder &);
  flatbuffers::Offset<TestReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TestReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<TestReply> CreateTestReply(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TestReplyBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TestReply> CreateTestReply(flatbuffers::FlatBufferBuilder &_fbb, const TestReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PolicyRequestEventT : public flatbuffers::NativeTable {
  typedef PolicyRequestEvent TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.PolicyRequestEventT";
  }
  std::string deviceID;
  std::vector<uint8_t> cardUID;
  PolicyRequestEventT() {
  }
};

struct PolicyRequestEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PolicyRequestEventT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PolicyRequestEventTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.PolicyRequestEvent";
  }
  enum {
    VT_DEVICEID = 4,
    VT_CARDUID = 6
  };
  const flatbuffers::String *deviceID() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::Vector<uint8_t> *cardUID() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CARDUID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.VerifyString(deviceID()) &&
           VerifyOffset(verifier, VT_CARDUID) &&
           verifier.VerifyVector(cardUID()) &&
           verifier.EndTable();
  }
  PolicyRequestEventT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PolicyRequestEventT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PolicyRequestEvent> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PolicyRequestEventT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PolicyRequestEventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deviceID(flatbuffers::Offset<flatbuffers::String> deviceID) {
    fbb_.AddOffset(PolicyRequestEvent::VT_DEVICEID, deviceID);
  }
  void add_cardUID(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> cardUID) {
    fbb_.AddOffset(PolicyRequestEvent::VT_CARDUID, cardUID);
  }
  explicit PolicyRequestEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PolicyRequestEventBuilder &operator=(const PolicyRequestEventBuilder &);
  flatbuffers::Offset<PolicyRequestEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PolicyRequestEvent>(end);
    return o;
  }
};

inline flatbuffers::Offset<PolicyRequestEvent> CreatePolicyRequestEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> deviceID = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> cardUID = 0) {
  PolicyRequestEventBuilder builder_(_fbb);
  builder_.add_cardUID(cardUID);
  builder_.add_deviceID(deviceID);
  return builder_.Finish();
}

inline flatbuffers::Offset<PolicyRequestEvent> CreatePolicyRequestEventDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *deviceID = nullptr,
    const std::vector<uint8_t> *cardUID = nullptr) {
  return nfcdoorz::ipc::policy::CreatePolicyRequestEvent(
      _fbb,
      deviceID ? _fbb.CreateString(deviceID) : 0,
      cardUID ? _fbb.CreateVector<uint8_t>(*cardUID) : 0);
}

flatbuffers::Offset<PolicyRequestEvent> CreatePolicyRequestEvent(flatbuffers::FlatBufferBuilder &_fbb, const PolicyRequestEventT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PolicyCallT : public flatbuffers::NativeTable {
  typedef PolicyCall TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.PolicyCallT";
  }
  uint64_t id;
  PolicyCallsUnion msg;
  PolicyCallT()
      : id(0) {
  }
};

struct PolicyCall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PolicyCallT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PolicyCallTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.PolicyCall";
  }
  enum {
    VT_ID = 4,
    VT_MSG_TYPE = 6,
    VT_MSG = 8
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  PolicyCalls msg_type() const {
    return static_cast<PolicyCalls>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const TestCall *msg_as_TestCall() const {
    return msg_type() == PolicyCalls::TestCall ? static_cast<const TestCall *>(msg()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyPolicyCalls(verifier, msg(), msg_type()) &&
           verifier.EndTable();
  }
  PolicyCallT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PolicyCallT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PolicyCall> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PolicyCallT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const TestCall *PolicyCall::msg_as<TestCall>() const {
  return msg_as_TestCall();
}

struct PolicyCallBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(PolicyCall::VT_ID, id, 0);
  }
  void add_msg_type(PolicyCalls msg_type) {
    fbb_.AddElement<uint8_t>(PolicyCall::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(PolicyCall::VT_MSG, msg);
  }
  explicit PolicyCallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PolicyCallBuilder &operator=(const PolicyCallBuilder &);
  flatbuffers::Offset<PolicyCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PolicyCall>(end);
    return o;
  }
};

inline flatbuffers::Offset<PolicyCall> CreatePolicyCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    PolicyCalls msg_type = PolicyCalls::NONE,
    flatbuffers::Offset<void> msg = 0) {
  PolicyCallBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

flatbuffers::Offset<PolicyCall> CreatePolicyCall(flatbuffers::FlatBufferBuilder &_fbb, const PolicyCallT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PolicyReplyT : public flatbuffers::NativeTable {
  typedef PolicyReply TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.PolicyReplyT";
  }
  uint64_t id;
  PolicyRepliesUnion msg;
  PolicyEventsUnion event;
  PolicyReplyT()
      : id(0) {
  }
};

struct PolicyReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PolicyReplyT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PolicyReplyTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.PolicyReply";
  }
  enum {
    VT_ID = 4,
    VT_MSG_TYPE = 6,
    VT_MSG = 8,
    VT_EVENT_TYPE = 10,
    VT_EVENT = 12
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  PolicyReplies msg_type() const {
    return static_cast<PolicyReplies>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const TestReply *msg_as_TestReply() const {
    return msg_type() == PolicyReplies::TestReply ? static_cast<const TestReply *>(msg()) : nullptr;
  }
  PolicyEvents event_type() const {
    return static_cast<PolicyEvents>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  template<typename T> const T *event_as() const;
  const PolicyRequestEvent *event_as_PolicyRequestEvent() const {
    return event_type() == PolicyEvents::PolicyRequestEvent ? static_cast<const PolicyRequestEvent *>(event()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyPolicyReplies(verifier, msg(), msg_type()) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE) &&
           VerifyOffset(verifier, VT_EVENT) &&
           VerifyPolicyEvents(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
  PolicyReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PolicyReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PolicyReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PolicyReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const TestReply *PolicyReply::msg_as<TestReply>() const {
  return msg_as_TestReply();
}

template<> inline const PolicyRequestEvent *PolicyReply::event_as<PolicyRequestEvent>() const {
  return event_as_PolicyRequestEvent();
}

struct PolicyReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(PolicyReply::VT_ID, id, 0);
  }
  void add_msg_type(PolicyReplies msg_type) {
    fbb_.AddElement<uint8_t>(PolicyReply::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(PolicyReply::VT_MSG, msg);
  }
  void add_event_type(PolicyEvents event_type) {
    fbb_.AddElement<uint8_t>(PolicyReply::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(flatbuffers::Offset<void> event) {
    fbb_.AddOffset(PolicyReply::VT_EVENT, event);
  }
  explicit PolicyReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PolicyReplyBuilder &operator=(const PolicyReplyBuilder &);
  flatbuffers::Offset<PolicyReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PolicyReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<PolicyReply> CreatePolicyReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    PolicyReplies msg_type = PolicyReplies::NONE,
    flatbuffers::Offset<void> msg = 0,
    PolicyEvents event_type = PolicyEvents::NONE,
    flatbuffers::Offset<void> event = 0) {
  PolicyReplyBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_event(event);
  builder_.add_msg(msg);
  builder_.add_event_type(event_type);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

flatbuffers::Offset<PolicyReply> CreatePolicyReply(flatbuffers::FlatBufferBuilder &_fbb, const PolicyReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ServerT : public flatbuffers::NativeTable {
  typedef Server TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.ServerT";
  }
  std::unique_ptr<PolicyCallT> call;
  std::unique_ptr<PolicyReplyT> reply;
  ServerT() {
  }
};

struct Server FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ServerTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.policy.Server";
  }
  enum {
    VT_CALL = 4,
    VT_REPLY = 6
  };
  const PolicyCall *call() const {
    return GetPointer<const PolicyCall *>(VT_CALL);
  }
  const PolicyReply *reply() const {
    return GetPointer<const PolicyReply *>(VT_REPLY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CALL) &&
           verifier.VerifyTable(call()) &&
           VerifyOffset(verifier, VT_REPLY) &&
           verifier.VerifyTable(reply()) &&
           verifier.EndTable();
  }
  ServerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ServerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Server> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ServerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_call(flatbuffers::Offset<PolicyCall> call) {
    fbb_.AddOffset(Server::VT_CALL, call);
  }
  void add_reply(flatbuffers::Offset<PolicyReply> reply) {
    fbb_.AddOffset(Server::VT_REPLY, reply);
  }
  explicit ServerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerBuilder &operator=(const ServerBuilder &);
  flatbuffers::Offset<Server> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Server>(end);
    return o;
  }
};

inline flatbuffers::Offset<Server> CreateServer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PolicyCall> call = 0,
    flatbuffers::Offset<PolicyReply> reply = 0) {
  ServerBuilder builder_(_fbb);
  builder_.add_reply(reply);
  builder_.add_call(call);
  return builder_.Finish();
}

flatbuffers::Offset<Server> CreateServer(flatbuffers::FlatBufferBuilder &_fbb, const ServerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TestCallT *TestCall::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TestCallT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TestCall::UnPackTo(TestCallT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TestCall> TestCall::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TestCallT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTestCall(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TestCall> CreateTestCall(flatbuffers::FlatBufferBuilder &_fbb, const TestCallT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TestCallT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return nfcdoorz::ipc::policy::CreateTestCall(
      _fbb);
}

inline TestReplyT *TestReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TestReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TestReply::UnPackTo(TestReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TestReply> TestReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TestReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTestReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TestReply> CreateTestReply(flatbuffers::FlatBufferBuilder &_fbb, const TestReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TestReplyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return nfcdoorz::ipc::policy::CreateTestReply(
      _fbb);
}

inline PolicyRequestEventT *PolicyRequestEvent::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PolicyRequestEventT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PolicyRequestEvent::UnPackTo(PolicyRequestEventT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = deviceID(); if (_e) _o->deviceID = _e->str(); };
  { auto _e = cardUID(); if (_e) { _o->cardUID.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cardUID[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<PolicyRequestEvent> PolicyRequestEvent::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PolicyRequestEventT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePolicyRequestEvent(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PolicyRequestEvent> CreatePolicyRequestEvent(flatbuffers::FlatBufferBuilder &_fbb, const PolicyRequestEventT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PolicyRequestEventT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _deviceID = _o->deviceID.empty() ? 0 : _fbb.CreateString(_o->deviceID);
  auto _cardUID = _o->cardUID.size() ? _fbb.CreateVector(_o->cardUID) : 0;
  return nfcdoorz::ipc::policy::CreatePolicyRequestEvent(
      _fbb,
      _deviceID,
      _cardUID);
}

inline PolicyCallT *PolicyCall::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PolicyCallT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PolicyCall::UnPackTo(PolicyCallT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = msg_type(); _o->msg.type = _e; };
  { auto _e = msg(); if (_e) _o->msg.value = PolicyCallsUnion::UnPack(_e, msg_type(), _resolver); };
}

inline flatbuffers::Offset<PolicyCall> PolicyCall::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PolicyCallT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePolicyCall(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PolicyCall> CreatePolicyCall(flatbuffers::FlatBufferBuilder &_fbb, const PolicyCallT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PolicyCallT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _msg_type = _o->msg.type;
  auto _msg = _o->msg.Pack(_fbb);
  return nfcdoorz::ipc::policy::CreatePolicyCall(
      _fbb,
      _id,
      _msg_type,
      _msg);
}

inline PolicyReplyT *PolicyReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PolicyReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PolicyReply::UnPackTo(PolicyReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = msg_type(); _o->msg.type = _e; };
  { auto _e = msg(); if (_e) _o->msg.value = PolicyRepliesUnion::UnPack(_e, msg_type(), _resolver); };
  { auto _e = event_type(); _o->event.type = _e; };
  { auto _e = event(); if (_e) _o->event.value = PolicyEventsUnion::UnPack(_e, event_type(), _resolver); };
}

inline flatbuffers::Offset<PolicyReply> PolicyReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PolicyReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePolicyReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PolicyReply> CreatePolicyReply(flatbuffers::FlatBufferBuilder &_fbb, const PolicyReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PolicyReplyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _msg_type = _o->msg.type;
  auto _msg = _o->msg.Pack(_fbb);
  auto _event_type = _o->event.type;
  auto _event = _o->event.Pack(_fbb);
  return nfcdoorz::ipc::policy::CreatePolicyReply(
      _fbb,
      _id,
      _msg_type,
      _msg,
      _event_type,
      _event);
}

inline ServerT *Server::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ServerT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Server::UnPackTo(ServerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = call(); if (_e) _o->call = std::unique_ptr<PolicyCallT>(_e->UnPack(_resolver)); };
  { auto _e = reply(); if (_e) _o->reply = std::unique_ptr<PolicyReplyT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Server> Server::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateServer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Server> CreateServer(flatbuffers::FlatBufferBuilder &_fbb, const ServerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ServerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _call = _o->call ? CreatePolicyCall(_fbb, _o->call.get(), _rehasher) : 0;
  auto _reply = _o->reply ? CreatePolicyReply(_fbb, _o->reply.get(), _rehasher) : 0;
  return nfcdoorz::ipc::policy::CreateServer(
      _fbb,
      _call,
      _reply);
}

inline bool VerifyPolicyCalls(flatbuffers::Verifier &verifier, const void *obj, PolicyCalls type) {
  switch (type) {
    case PolicyCalls::NONE: {
      return true;
    }
    case PolicyCalls::TestCall: {
      auto ptr = reinterpret_cast<const TestCall *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyPolicyCallsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPolicyCalls(
        verifier,  values->Get(i), types->GetEnum<PolicyCalls>(i))) {
      return false;
    }
  }
  return true;
}

inline void *PolicyCallsUnion::UnPack(const void *obj, PolicyCalls type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case PolicyCalls::TestCall: {
      auto ptr = reinterpret_cast<const TestCall *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> PolicyCallsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case PolicyCalls::TestCall: {
      auto ptr = reinterpret_cast<const TestCallT *>(value);
      return CreateTestCall(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline PolicyCallsUnion::PolicyCallsUnion(const PolicyCallsUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case PolicyCalls::TestCall: {
      value = new TestCallT(*reinterpret_cast<TestCallT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void PolicyCallsUnion::Reset() {
  switch (type) {
    case PolicyCalls::TestCall: {
      auto ptr = reinterpret_cast<TestCallT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = PolicyCalls::NONE;
}

inline bool VerifyPolicyReplies(flatbuffers::Verifier &verifier, const void *obj, PolicyReplies type) {
  switch (type) {
    case PolicyReplies::NONE: {
      return true;
    }
    case PolicyReplies::TestReply: {
      auto ptr = reinterpret_cast<const TestReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyPolicyRepliesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPolicyReplies(
        verifier,  values->Get(i), types->GetEnum<PolicyReplies>(i))) {
      return false;
    }
  }
  return true;
}

inline void *PolicyRepliesUnion::UnPack(const void *obj, PolicyReplies type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case PolicyReplies::TestReply: {
      auto ptr = reinterpret_cast<const TestReply *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> PolicyRepliesUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case PolicyReplies::TestReply: {
      auto ptr = reinterpret_cast<const TestReplyT *>(value);
      return CreateTestReply(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline PolicyRepliesUnion::PolicyRepliesUnion(const PolicyRepliesUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case PolicyReplies::TestReply: {
      value = new TestReplyT(*reinterpret_cast<TestReplyT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void PolicyRepliesUnion::Reset() {
  switch (type) {
    case PolicyReplies::TestReply: {
      auto ptr = reinterpret_cast<TestReplyT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = PolicyReplies::NONE;
}

inline bool VerifyPolicyEvents(flatbuffers::Verifier &verifier, const void *obj, PolicyEvents type) {
  switch (type) {
    case PolicyEvents::NONE: {
      return true;
    }
    case PolicyEvents::PolicyRequestEvent: {
      auto ptr = reinterpret_cast<const PolicyRequestEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyPolicyEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPolicyEvents(
        verifier,  values->Get(i), types->GetEnum<PolicyEvents>(i))) {
      return false;
    }
  }
  return true;
}

inline void *PolicyEventsUnion::UnPack(const void *obj, PolicyEvents type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case PolicyEvents::PolicyRequestEvent: {
      auto ptr = reinterpret_cast<const PolicyRequestEvent *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> PolicyEventsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case PolicyEvents::PolicyRequestEvent: {
      auto ptr = reinterpret_cast<const PolicyRequestEventT *>(value);
      return CreatePolicyRequestEvent(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline PolicyEventsUnion::PolicyEventsUnion(const PolicyEventsUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case PolicyEvents::PolicyRequestEvent: {
      value = new PolicyRequestEventT(*reinterpret_cast<PolicyRequestEventT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void PolicyEventsUnion::Reset() {
  switch (type) {
    case PolicyEvents::PolicyRequestEvent: {
      auto ptr = reinterpret_cast<PolicyRequestEventT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = PolicyEvents::NONE;
}

inline const flatbuffers::TypeTable *PolicyCallsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TestCallTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "TestCall"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PolicyRepliesTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TestReplyTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "TestReply"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PolicyEventsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PolicyRequestEventTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "PolicyRequestEvent"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TestCallTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TestReplyTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PolicyRequestEventTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const char * const names[] = {
    "deviceID",
    "cardUID"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PolicyCallTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PolicyCallsTypeTable
  };
  static const char * const names[] = {
    "id",
    "msg_type",
    "msg"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PolicyReplyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_UTYPE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PolicyRepliesTypeTable,
    PolicyEventsTypeTable
  };
  static const char * const names[] = {
    "id",
    "msg_type",
    "msg",
    "event_type",
    "event"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ServerTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PolicyCallTypeTable,
    PolicyReplyTypeTable
  };
  static const char * const names[] = {
    "call",
    "reply"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

}  // namespace policy
}  // namespace ipc
}  // namespace nfcdoorz

#endif  // FLATBUFFERS_GENERATED_IPCPOLICY_NFCDOORZ_IPC_POLICY_H_
