// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_IPCAPI_NFCDOORZ_IPC_API_H_
#define FLATBUFFERS_GENERATED_IPCAPI_NFCDOORZ_IPC_API_H_

#include "flatbuffers/flatbuffers.h"

namespace nfcdoorz {
namespace ipc {
namespace api {

struct StatusCall;
struct StatusCallT;

struct Process;
struct ProcessT;

struct StatusReply;
struct StatusReplyT;

struct CreateAuthenticatorCall;
struct CreateAuthenticatorCallT;

struct CreateAuthenticatorReply;
struct CreateAuthenticatorReplyT;

struct DestroyAuthenticatorCall;
struct DestroyAuthenticatorCallT;

struct DestroyAuthenticatorReply;
struct DestroyAuthenticatorReplyT;

struct AuthenticatorExitEvent;
struct AuthenticatorExitEventT;

struct Call;
struct CallT;

struct Reply;
struct ReplyT;

struct Server;
struct ServerT;

inline const flatbuffers::TypeTable *StatusCallTypeTable();

inline const flatbuffers::TypeTable *ProcessTypeTable();

inline const flatbuffers::TypeTable *StatusReplyTypeTable();

inline const flatbuffers::TypeTable *CreateAuthenticatorCallTypeTable();

inline const flatbuffers::TypeTable *CreateAuthenticatorReplyTypeTable();

inline const flatbuffers::TypeTable *DestroyAuthenticatorCallTypeTable();

inline const flatbuffers::TypeTable *DestroyAuthenticatorReplyTypeTable();

inline const flatbuffers::TypeTable *AuthenticatorExitEventTypeTable();

inline const flatbuffers::TypeTable *CallTypeTable();

inline const flatbuffers::TypeTable *ReplyTypeTable();

inline const flatbuffers::TypeTable *ServerTypeTable();

enum class Calls : uint8_t {
  NONE = 0,
  StatusCall = 1,
  CreateAuthenticatorCall = 2,
  DestroyAuthenticatorCall = 3,
  MIN = NONE,
  MAX = DestroyAuthenticatorCall
};

inline const Calls (&EnumValuesCalls())[4] {
  static const Calls values[] = {
    Calls::NONE,
    Calls::StatusCall,
    Calls::CreateAuthenticatorCall,
    Calls::DestroyAuthenticatorCall
  };
  return values;
}

inline const char * const *EnumNamesCalls() {
  static const char * const names[] = {
    "NONE",
    "StatusCall",
    "CreateAuthenticatorCall",
    "DestroyAuthenticatorCall",
    nullptr
  };
  return names;
}

inline const char *EnumNameCalls(Calls e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCalls()[index];
}

template<typename T> struct CallsTraits {
  static const Calls enum_value = Calls::NONE;
};

template<> struct CallsTraits<StatusCall> {
  static const Calls enum_value = Calls::StatusCall;
};

template<> struct CallsTraits<CreateAuthenticatorCall> {
  static const Calls enum_value = Calls::CreateAuthenticatorCall;
};

template<> struct CallsTraits<DestroyAuthenticatorCall> {
  static const Calls enum_value = Calls::DestroyAuthenticatorCall;
};

struct CallsUnion {
  Calls type;
  void *value;

  CallsUnion() : type(Calls::NONE), value(nullptr) {}
  CallsUnion(CallsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Calls::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  CallsUnion(const CallsUnion &) FLATBUFFERS_NOEXCEPT;
  CallsUnion &operator=(const CallsUnion &u) FLATBUFFERS_NOEXCEPT
    { CallsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  CallsUnion &operator=(CallsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~CallsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = CallsTraits<typename T::TableType>::enum_value;
    if (type != Calls::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Calls type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  StatusCallT *AsStatusCall() {
    return type == Calls::StatusCall ?
      reinterpret_cast<StatusCallT *>(value) : nullptr;
  }
  const StatusCallT *AsStatusCall() const {
    return type == Calls::StatusCall ?
      reinterpret_cast<const StatusCallT *>(value) : nullptr;
  }
  CreateAuthenticatorCallT *AsCreateAuthenticatorCall() {
    return type == Calls::CreateAuthenticatorCall ?
      reinterpret_cast<CreateAuthenticatorCallT *>(value) : nullptr;
  }
  const CreateAuthenticatorCallT *AsCreateAuthenticatorCall() const {
    return type == Calls::CreateAuthenticatorCall ?
      reinterpret_cast<const CreateAuthenticatorCallT *>(value) : nullptr;
  }
  DestroyAuthenticatorCallT *AsDestroyAuthenticatorCall() {
    return type == Calls::DestroyAuthenticatorCall ?
      reinterpret_cast<DestroyAuthenticatorCallT *>(value) : nullptr;
  }
  const DestroyAuthenticatorCallT *AsDestroyAuthenticatorCall() const {
    return type == Calls::DestroyAuthenticatorCall ?
      reinterpret_cast<const DestroyAuthenticatorCallT *>(value) : nullptr;
  }
};

bool VerifyCalls(flatbuffers::Verifier &verifier, const void *obj, Calls type);
bool VerifyCallsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class Replies : uint8_t {
  NONE = 0,
  StatusReply = 1,
  CreateAuthenticatorReply = 2,
  DestroyAuthenticatorReply = 3,
  MIN = NONE,
  MAX = DestroyAuthenticatorReply
};

inline const Replies (&EnumValuesReplies())[4] {
  static const Replies values[] = {
    Replies::NONE,
    Replies::StatusReply,
    Replies::CreateAuthenticatorReply,
    Replies::DestroyAuthenticatorReply
  };
  return values;
}

inline const char * const *EnumNamesReplies() {
  static const char * const names[] = {
    "NONE",
    "StatusReply",
    "CreateAuthenticatorReply",
    "DestroyAuthenticatorReply",
    nullptr
  };
  return names;
}

inline const char *EnumNameReplies(Replies e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesReplies()[index];
}

template<typename T> struct RepliesTraits {
  static const Replies enum_value = Replies::NONE;
};

template<> struct RepliesTraits<StatusReply> {
  static const Replies enum_value = Replies::StatusReply;
};

template<> struct RepliesTraits<CreateAuthenticatorReply> {
  static const Replies enum_value = Replies::CreateAuthenticatorReply;
};

template<> struct RepliesTraits<DestroyAuthenticatorReply> {
  static const Replies enum_value = Replies::DestroyAuthenticatorReply;
};

struct RepliesUnion {
  Replies type;
  void *value;

  RepliesUnion() : type(Replies::NONE), value(nullptr) {}
  RepliesUnion(RepliesUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Replies::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  RepliesUnion(const RepliesUnion &) FLATBUFFERS_NOEXCEPT;
  RepliesUnion &operator=(const RepliesUnion &u) FLATBUFFERS_NOEXCEPT
    { RepliesUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  RepliesUnion &operator=(RepliesUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~RepliesUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = RepliesTraits<typename T::TableType>::enum_value;
    if (type != Replies::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Replies type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  StatusReplyT *AsStatusReply() {
    return type == Replies::StatusReply ?
      reinterpret_cast<StatusReplyT *>(value) : nullptr;
  }
  const StatusReplyT *AsStatusReply() const {
    return type == Replies::StatusReply ?
      reinterpret_cast<const StatusReplyT *>(value) : nullptr;
  }
  CreateAuthenticatorReplyT *AsCreateAuthenticatorReply() {
    return type == Replies::CreateAuthenticatorReply ?
      reinterpret_cast<CreateAuthenticatorReplyT *>(value) : nullptr;
  }
  const CreateAuthenticatorReplyT *AsCreateAuthenticatorReply() const {
    return type == Replies::CreateAuthenticatorReply ?
      reinterpret_cast<const CreateAuthenticatorReplyT *>(value) : nullptr;
  }
  DestroyAuthenticatorReplyT *AsDestroyAuthenticatorReply() {
    return type == Replies::DestroyAuthenticatorReply ?
      reinterpret_cast<DestroyAuthenticatorReplyT *>(value) : nullptr;
  }
  const DestroyAuthenticatorReplyT *AsDestroyAuthenticatorReply() const {
    return type == Replies::DestroyAuthenticatorReply ?
      reinterpret_cast<const DestroyAuthenticatorReplyT *>(value) : nullptr;
  }
};

bool VerifyReplies(flatbuffers::Verifier &verifier, const void *obj, Replies type);
bool VerifyRepliesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class Events : uint8_t {
  NONE = 0,
  AuthenticatorExitEvent = 1,
  MIN = NONE,
  MAX = AuthenticatorExitEvent
};

inline const Events (&EnumValuesEvents())[2] {
  static const Events values[] = {
    Events::NONE,
    Events::AuthenticatorExitEvent
  };
  return values;
}

inline const char * const *EnumNamesEvents() {
  static const char * const names[] = {
    "NONE",
    "AuthenticatorExitEvent",
    nullptr
  };
  return names;
}

inline const char *EnumNameEvents(Events e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEvents()[index];
}

template<typename T> struct EventsTraits {
  static const Events enum_value = Events::NONE;
};

template<> struct EventsTraits<AuthenticatorExitEvent> {
  static const Events enum_value = Events::AuthenticatorExitEvent;
};

struct EventsUnion {
  Events type;
  void *value;

  EventsUnion() : type(Events::NONE), value(nullptr) {}
  EventsUnion(EventsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Events::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  EventsUnion(const EventsUnion &) FLATBUFFERS_NOEXCEPT;
  EventsUnion &operator=(const EventsUnion &u) FLATBUFFERS_NOEXCEPT
    { EventsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  EventsUnion &operator=(EventsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~EventsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = EventsTraits<typename T::TableType>::enum_value;
    if (type != Events::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Events type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  AuthenticatorExitEventT *AsAuthenticatorExitEvent() {
    return type == Events::AuthenticatorExitEvent ?
      reinterpret_cast<AuthenticatorExitEventT *>(value) : nullptr;
  }
  const AuthenticatorExitEventT *AsAuthenticatorExitEvent() const {
    return type == Events::AuthenticatorExitEvent ?
      reinterpret_cast<const AuthenticatorExitEventT *>(value) : nullptr;
  }
};

bool VerifyEvents(flatbuffers::Verifier &verifier, const void *obj, Events type);
bool VerifyEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct StatusCallT : public flatbuffers::NativeTable {
  typedef StatusCall TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.StatusCallT";
  }
  StatusCallT() {
  }
};

struct StatusCall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatusCallT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StatusCallTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.StatusCall";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  StatusCallT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StatusCallT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StatusCall> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StatusCallT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StatusCallBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit StatusCallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StatusCallBuilder &operator=(const StatusCallBuilder &);
  flatbuffers::Offset<StatusCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatusCall>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatusCall> CreateStatusCall(
    flatbuffers::FlatBufferBuilder &_fbb) {
  StatusCallBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<StatusCall> CreateStatusCall(flatbuffers::FlatBufferBuilder &_fbb, const StatusCallT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProcessT : public flatbuffers::NativeTable {
  typedef Process TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.ProcessT";
  }
  int32_t pid;
  std::string name;
  std::vector<std::string> args;
  ProcessT()
      : pid(0) {
  }
};

struct Process FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProcessT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ProcessTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.Process";
  }
  enum {
    VT_PID = 4,
    VT_NAME = 6,
    VT_ARGS = 8
  };
  int32_t pid() const {
    return GetField<int32_t>(VT_PID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *args() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ARGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_ARGS) &&
           verifier.VerifyVector(args()) &&
           verifier.VerifyVectorOfStrings(args()) &&
           verifier.EndTable();
  }
  ProcessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProcessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Process> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProcessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProcessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pid(int32_t pid) {
    fbb_.AddElement<int32_t>(Process::VT_PID, pid, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Process::VT_NAME, name);
  }
  void add_args(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> args) {
    fbb_.AddOffset(Process::VT_ARGS, args);
  }
  explicit ProcessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProcessBuilder &operator=(const ProcessBuilder &);
  flatbuffers::Offset<Process> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Process>(end);
    return o;
  }
};

inline flatbuffers::Offset<Process> CreateProcess(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pid = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> args = 0) {
  ProcessBuilder builder_(_fbb);
  builder_.add_args(args);
  builder_.add_name(name);
  builder_.add_pid(pid);
  return builder_.Finish();
}

inline flatbuffers::Offset<Process> CreateProcessDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pid = 0,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *args = nullptr) {
  return nfcdoorz::ipc::api::CreateProcess(
      _fbb,
      pid,
      name ? _fbb.CreateString(name) : 0,
      args ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*args) : 0);
}

flatbuffers::Offset<Process> CreateProcess(flatbuffers::FlatBufferBuilder &_fbb, const ProcessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StatusReplyT : public flatbuffers::NativeTable {
  typedef StatusReply TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.StatusReplyT";
  }
  std::vector<std::unique_ptr<ProcessT>> processes;
  StatusReplyT() {
  }
};

struct StatusReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatusReplyT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StatusReplyTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.StatusReply";
  }
  enum {
    VT_PROCESSES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Process>> *processes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Process>> *>(VT_PROCESSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROCESSES) &&
           verifier.VerifyVector(processes()) &&
           verifier.VerifyVectorOfTables(processes()) &&
           verifier.EndTable();
  }
  StatusReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StatusReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StatusReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StatusReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StatusReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_processes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Process>>> processes) {
    fbb_.AddOffset(StatusReply::VT_PROCESSES, processes);
  }
  explicit StatusReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StatusReplyBuilder &operator=(const StatusReplyBuilder &);
  flatbuffers::Offset<StatusReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatusReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatusReply> CreateStatusReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Process>>> processes = 0) {
  StatusReplyBuilder builder_(_fbb);
  builder_.add_processes(processes);
  return builder_.Finish();
}

inline flatbuffers::Offset<StatusReply> CreateStatusReplyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Process>> *processes = nullptr) {
  return nfcdoorz::ipc::api::CreateStatusReply(
      _fbb,
      processes ? _fbb.CreateVector<flatbuffers::Offset<Process>>(*processes) : 0);
}

flatbuffers::Offset<StatusReply> CreateStatusReply(flatbuffers::FlatBufferBuilder &_fbb, const StatusReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CreateAuthenticatorCallT : public flatbuffers::NativeTable {
  typedef CreateAuthenticatorCall TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.CreateAuthenticatorCallT";
  }
  std::string ttyName;
  std::string deviceID;
  CreateAuthenticatorCallT() {
  }
};

struct CreateAuthenticatorCall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreateAuthenticatorCallT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CreateAuthenticatorCallTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.CreateAuthenticatorCall";
  }
  enum {
    VT_TTYNAME = 4,
    VT_DEVICEID = 6
  };
  const flatbuffers::String *ttyName() const {
    return GetPointer<const flatbuffers::String *>(VT_TTYNAME);
  }
  const flatbuffers::String *deviceID() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TTYNAME) &&
           verifier.VerifyString(ttyName()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.VerifyString(deviceID()) &&
           verifier.EndTable();
  }
  CreateAuthenticatorCallT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CreateAuthenticatorCallT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CreateAuthenticatorCall> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreateAuthenticatorCallT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CreateAuthenticatorCallBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ttyName(flatbuffers::Offset<flatbuffers::String> ttyName) {
    fbb_.AddOffset(CreateAuthenticatorCall::VT_TTYNAME, ttyName);
  }
  void add_deviceID(flatbuffers::Offset<flatbuffers::String> deviceID) {
    fbb_.AddOffset(CreateAuthenticatorCall::VT_DEVICEID, deviceID);
  }
  explicit CreateAuthenticatorCallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CreateAuthenticatorCallBuilder &operator=(const CreateAuthenticatorCallBuilder &);
  flatbuffers::Offset<CreateAuthenticatorCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CreateAuthenticatorCall>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreateAuthenticatorCall> CreateCreateAuthenticatorCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ttyName = 0,
    flatbuffers::Offset<flatbuffers::String> deviceID = 0) {
  CreateAuthenticatorCallBuilder builder_(_fbb);
  builder_.add_deviceID(deviceID);
  builder_.add_ttyName(ttyName);
  return builder_.Finish();
}

inline flatbuffers::Offset<CreateAuthenticatorCall> CreateCreateAuthenticatorCallDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ttyName = nullptr,
    const char *deviceID = nullptr) {
  return nfcdoorz::ipc::api::CreateCreateAuthenticatorCall(
      _fbb,
      ttyName ? _fbb.CreateString(ttyName) : 0,
      deviceID ? _fbb.CreateString(deviceID) : 0);
}

flatbuffers::Offset<CreateAuthenticatorCall> CreateCreateAuthenticatorCall(flatbuffers::FlatBufferBuilder &_fbb, const CreateAuthenticatorCallT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CreateAuthenticatorReplyT : public flatbuffers::NativeTable {
  typedef CreateAuthenticatorReply TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.CreateAuthenticatorReplyT";
  }
  bool status;
  CreateAuthenticatorReplyT()
      : status(false) {
  }
};

struct CreateAuthenticatorReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreateAuthenticatorReplyT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CreateAuthenticatorReplyTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.CreateAuthenticatorReply";
  }
  enum {
    VT_STATUS = 4
  };
  bool status() const {
    return GetField<uint8_t>(VT_STATUS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           verifier.EndTable();
  }
  CreateAuthenticatorReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CreateAuthenticatorReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CreateAuthenticatorReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreateAuthenticatorReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CreateAuthenticatorReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(bool status) {
    fbb_.AddElement<uint8_t>(CreateAuthenticatorReply::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  explicit CreateAuthenticatorReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CreateAuthenticatorReplyBuilder &operator=(const CreateAuthenticatorReplyBuilder &);
  flatbuffers::Offset<CreateAuthenticatorReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CreateAuthenticatorReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreateAuthenticatorReply> CreateCreateAuthenticatorReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool status = false) {
  CreateAuthenticatorReplyBuilder builder_(_fbb);
  builder_.add_status(status);
  return builder_.Finish();
}

flatbuffers::Offset<CreateAuthenticatorReply> CreateCreateAuthenticatorReply(flatbuffers::FlatBufferBuilder &_fbb, const CreateAuthenticatorReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DestroyAuthenticatorCallT : public flatbuffers::NativeTable {
  typedef DestroyAuthenticatorCall TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.DestroyAuthenticatorCallT";
  }
  std::string deviceID;
  DestroyAuthenticatorCallT() {
  }
};

struct DestroyAuthenticatorCall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DestroyAuthenticatorCallT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DestroyAuthenticatorCallTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.DestroyAuthenticatorCall";
  }
  enum {
    VT_DEVICEID = 4
  };
  const flatbuffers::String *deviceID() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.VerifyString(deviceID()) &&
           verifier.EndTable();
  }
  DestroyAuthenticatorCallT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DestroyAuthenticatorCallT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DestroyAuthenticatorCall> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DestroyAuthenticatorCallT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DestroyAuthenticatorCallBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deviceID(flatbuffers::Offset<flatbuffers::String> deviceID) {
    fbb_.AddOffset(DestroyAuthenticatorCall::VT_DEVICEID, deviceID);
  }
  explicit DestroyAuthenticatorCallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DestroyAuthenticatorCallBuilder &operator=(const DestroyAuthenticatorCallBuilder &);
  flatbuffers::Offset<DestroyAuthenticatorCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DestroyAuthenticatorCall>(end);
    return o;
  }
};

inline flatbuffers::Offset<DestroyAuthenticatorCall> CreateDestroyAuthenticatorCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> deviceID = 0) {
  DestroyAuthenticatorCallBuilder builder_(_fbb);
  builder_.add_deviceID(deviceID);
  return builder_.Finish();
}

inline flatbuffers::Offset<DestroyAuthenticatorCall> CreateDestroyAuthenticatorCallDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *deviceID = nullptr) {
  return nfcdoorz::ipc::api::CreateDestroyAuthenticatorCall(
      _fbb,
      deviceID ? _fbb.CreateString(deviceID) : 0);
}

flatbuffers::Offset<DestroyAuthenticatorCall> CreateDestroyAuthenticatorCall(flatbuffers::FlatBufferBuilder &_fbb, const DestroyAuthenticatorCallT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DestroyAuthenticatorReplyT : public flatbuffers::NativeTable {
  typedef DestroyAuthenticatorReply TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.DestroyAuthenticatorReplyT";
  }
  bool status;
  DestroyAuthenticatorReplyT()
      : status(false) {
  }
};

struct DestroyAuthenticatorReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DestroyAuthenticatorReplyT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DestroyAuthenticatorReplyTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.DestroyAuthenticatorReply";
  }
  enum {
    VT_STATUS = 4
  };
  bool status() const {
    return GetField<uint8_t>(VT_STATUS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           verifier.EndTable();
  }
  DestroyAuthenticatorReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DestroyAuthenticatorReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DestroyAuthenticatorReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DestroyAuthenticatorReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DestroyAuthenticatorReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(bool status) {
    fbb_.AddElement<uint8_t>(DestroyAuthenticatorReply::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  explicit DestroyAuthenticatorReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DestroyAuthenticatorReplyBuilder &operator=(const DestroyAuthenticatorReplyBuilder &);
  flatbuffers::Offset<DestroyAuthenticatorReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DestroyAuthenticatorReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<DestroyAuthenticatorReply> CreateDestroyAuthenticatorReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool status = false) {
  DestroyAuthenticatorReplyBuilder builder_(_fbb);
  builder_.add_status(status);
  return builder_.Finish();
}

flatbuffers::Offset<DestroyAuthenticatorReply> CreateDestroyAuthenticatorReply(flatbuffers::FlatBufferBuilder &_fbb, const DestroyAuthenticatorReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthenticatorExitEventT : public flatbuffers::NativeTable {
  typedef AuthenticatorExitEvent TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.AuthenticatorExitEventT";
  }
  std::string deviceID;
  AuthenticatorExitEventT() {
  }
};

struct AuthenticatorExitEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AuthenticatorExitEventT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AuthenticatorExitEventTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.AuthenticatorExitEvent";
  }
  enum {
    VT_DEVICEID = 4
  };
  const flatbuffers::String *deviceID() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.VerifyString(deviceID()) &&
           verifier.EndTable();
  }
  AuthenticatorExitEventT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AuthenticatorExitEventT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AuthenticatorExitEvent> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticatorExitEventT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AuthenticatorExitEventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deviceID(flatbuffers::Offset<flatbuffers::String> deviceID) {
    fbb_.AddOffset(AuthenticatorExitEvent::VT_DEVICEID, deviceID);
  }
  explicit AuthenticatorExitEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AuthenticatorExitEventBuilder &operator=(const AuthenticatorExitEventBuilder &);
  flatbuffers::Offset<AuthenticatorExitEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AuthenticatorExitEvent>(end);
    return o;
  }
};

inline flatbuffers::Offset<AuthenticatorExitEvent> CreateAuthenticatorExitEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> deviceID = 0) {
  AuthenticatorExitEventBuilder builder_(_fbb);
  builder_.add_deviceID(deviceID);
  return builder_.Finish();
}

inline flatbuffers::Offset<AuthenticatorExitEvent> CreateAuthenticatorExitEventDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *deviceID = nullptr) {
  return nfcdoorz::ipc::api::CreateAuthenticatorExitEvent(
      _fbb,
      deviceID ? _fbb.CreateString(deviceID) : 0);
}

flatbuffers::Offset<AuthenticatorExitEvent> CreateAuthenticatorExitEvent(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticatorExitEventT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CallT : public flatbuffers::NativeTable {
  typedef Call TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.CallT";
  }
  uint64_t id;
  CallsUnion msg;
  CallT()
      : id(0) {
  }
};

struct Call FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CallT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CallTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.Call";
  }
  enum {
    VT_ID = 4,
    VT_MSG_TYPE = 6,
    VT_MSG = 8
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  Calls msg_type() const {
    return static_cast<Calls>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const StatusCall *msg_as_StatusCall() const {
    return msg_type() == Calls::StatusCall ? static_cast<const StatusCall *>(msg()) : nullptr;
  }
  const CreateAuthenticatorCall *msg_as_CreateAuthenticatorCall() const {
    return msg_type() == Calls::CreateAuthenticatorCall ? static_cast<const CreateAuthenticatorCall *>(msg()) : nullptr;
  }
  const DestroyAuthenticatorCall *msg_as_DestroyAuthenticatorCall() const {
    return msg_type() == Calls::DestroyAuthenticatorCall ? static_cast<const DestroyAuthenticatorCall *>(msg()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyCalls(verifier, msg(), msg_type()) &&
           verifier.EndTable();
  }
  CallT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CallT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Call> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const StatusCall *Call::msg_as<StatusCall>() const {
  return msg_as_StatusCall();
}

template<> inline const CreateAuthenticatorCall *Call::msg_as<CreateAuthenticatorCall>() const {
  return msg_as_CreateAuthenticatorCall();
}

template<> inline const DestroyAuthenticatorCall *Call::msg_as<DestroyAuthenticatorCall>() const {
  return msg_as_DestroyAuthenticatorCall();
}

struct CallBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Call::VT_ID, id, 0);
  }
  void add_msg_type(Calls msg_type) {
    fbb_.AddElement<uint8_t>(Call::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(Call::VT_MSG, msg);
  }
  explicit CallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallBuilder &operator=(const CallBuilder &);
  flatbuffers::Offset<Call> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Call>(end);
    return o;
  }
};

inline flatbuffers::Offset<Call> CreateCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    Calls msg_type = Calls::NONE,
    flatbuffers::Offset<void> msg = 0) {
  CallBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

flatbuffers::Offset<Call> CreateCall(flatbuffers::FlatBufferBuilder &_fbb, const CallT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReplyT : public flatbuffers::NativeTable {
  typedef Reply TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.ReplyT";
  }
  uint64_t id;
  RepliesUnion msg;
  EventsUnion event;
  ReplyT()
      : id(0) {
  }
};

struct Reply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReplyT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReplyTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.Reply";
  }
  enum {
    VT_ID = 4,
    VT_MSG_TYPE = 6,
    VT_MSG = 8,
    VT_EVENT_TYPE = 10,
    VT_EVENT = 12
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  Replies msg_type() const {
    return static_cast<Replies>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const StatusReply *msg_as_StatusReply() const {
    return msg_type() == Replies::StatusReply ? static_cast<const StatusReply *>(msg()) : nullptr;
  }
  const CreateAuthenticatorReply *msg_as_CreateAuthenticatorReply() const {
    return msg_type() == Replies::CreateAuthenticatorReply ? static_cast<const CreateAuthenticatorReply *>(msg()) : nullptr;
  }
  const DestroyAuthenticatorReply *msg_as_DestroyAuthenticatorReply() const {
    return msg_type() == Replies::DestroyAuthenticatorReply ? static_cast<const DestroyAuthenticatorReply *>(msg()) : nullptr;
  }
  Events event_type() const {
    return static_cast<Events>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  template<typename T> const T *event_as() const;
  const AuthenticatorExitEvent *event_as_AuthenticatorExitEvent() const {
    return event_type() == Events::AuthenticatorExitEvent ? static_cast<const AuthenticatorExitEvent *>(event()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyReplies(verifier, msg(), msg_type()) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE) &&
           VerifyOffset(verifier, VT_EVENT) &&
           VerifyEvents(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
  ReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const StatusReply *Reply::msg_as<StatusReply>() const {
  return msg_as_StatusReply();
}

template<> inline const CreateAuthenticatorReply *Reply::msg_as<CreateAuthenticatorReply>() const {
  return msg_as_CreateAuthenticatorReply();
}

template<> inline const DestroyAuthenticatorReply *Reply::msg_as<DestroyAuthenticatorReply>() const {
  return msg_as_DestroyAuthenticatorReply();
}

template<> inline const AuthenticatorExitEvent *Reply::event_as<AuthenticatorExitEvent>() const {
  return event_as_AuthenticatorExitEvent();
}

struct ReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Reply::VT_ID, id, 0);
  }
  void add_msg_type(Replies msg_type) {
    fbb_.AddElement<uint8_t>(Reply::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(Reply::VT_MSG, msg);
  }
  void add_event_type(Events event_type) {
    fbb_.AddElement<uint8_t>(Reply::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(flatbuffers::Offset<void> event) {
    fbb_.AddOffset(Reply::VT_EVENT, event);
  }
  explicit ReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReplyBuilder &operator=(const ReplyBuilder &);
  flatbuffers::Offset<Reply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reply>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply> CreateReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    Replies msg_type = Replies::NONE,
    flatbuffers::Offset<void> msg = 0,
    Events event_type = Events::NONE,
    flatbuffers::Offset<void> event = 0) {
  ReplyBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_event(event);
  builder_.add_msg(msg);
  builder_.add_event_type(event_type);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

flatbuffers::Offset<Reply> CreateReply(flatbuffers::FlatBufferBuilder &_fbb, const ReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ServerT : public flatbuffers::NativeTable {
  typedef Server TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.ServerT";
  }
  std::unique_ptr<CallT> call;
  std::unique_ptr<ReplyT> reply;
  ServerT() {
  }
};

struct Server FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ServerTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.Server";
  }
  enum {
    VT_CALL = 4,
    VT_REPLY = 6
  };
  const Call *call() const {
    return GetPointer<const Call *>(VT_CALL);
  }
  const Reply *reply() const {
    return GetPointer<const Reply *>(VT_REPLY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CALL) &&
           verifier.VerifyTable(call()) &&
           VerifyOffset(verifier, VT_REPLY) &&
           verifier.VerifyTable(reply()) &&
           verifier.EndTable();
  }
  ServerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ServerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Server> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ServerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_call(flatbuffers::Offset<Call> call) {
    fbb_.AddOffset(Server::VT_CALL, call);
  }
  void add_reply(flatbuffers::Offset<Reply> reply) {
    fbb_.AddOffset(Server::VT_REPLY, reply);
  }
  explicit ServerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerBuilder &operator=(const ServerBuilder &);
  flatbuffers::Offset<Server> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Server>(end);
    return o;
  }
};

inline flatbuffers::Offset<Server> CreateServer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Call> call = 0,
    flatbuffers::Offset<Reply> reply = 0) {
  ServerBuilder builder_(_fbb);
  builder_.add_reply(reply);
  builder_.add_call(call);
  return builder_.Finish();
}

flatbuffers::Offset<Server> CreateServer(flatbuffers::FlatBufferBuilder &_fbb, const ServerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline StatusCallT *StatusCall::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StatusCallT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StatusCall::UnPackTo(StatusCallT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<StatusCall> StatusCall::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StatusCallT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStatusCall(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StatusCall> CreateStatusCall(flatbuffers::FlatBufferBuilder &_fbb, const StatusCallT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StatusCallT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return nfcdoorz::ipc::api::CreateStatusCall(
      _fbb);
}

inline ProcessT *Process::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ProcessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Process::UnPackTo(ProcessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pid(); _o->pid = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = args(); if (_e) { _o->args.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->args[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<Process> Process::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProcessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProcess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Process> CreateProcess(flatbuffers::FlatBufferBuilder &_fbb, const ProcessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProcessT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pid = _o->pid;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _args = _o->args.size() ? _fbb.CreateVectorOfStrings(_o->args) : 0;
  return nfcdoorz::ipc::api::CreateProcess(
      _fbb,
      _pid,
      _name,
      _args);
}

inline StatusReplyT *StatusReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StatusReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StatusReply::UnPackTo(StatusReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = processes(); if (_e) { _o->processes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->processes[_i] = std::unique_ptr<ProcessT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<StatusReply> StatusReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StatusReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStatusReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StatusReply> CreateStatusReply(flatbuffers::FlatBufferBuilder &_fbb, const StatusReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StatusReplyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _processes = _o->processes.size() ? _fbb.CreateVector<flatbuffers::Offset<Process>> (_o->processes.size(), [](size_t i, _VectorArgs *__va) { return CreateProcess(*__va->__fbb, __va->__o->processes[i].get(), __va->__rehasher); }, &_va ) : 0;
  return nfcdoorz::ipc::api::CreateStatusReply(
      _fbb,
      _processes);
}

inline CreateAuthenticatorCallT *CreateAuthenticatorCall::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CreateAuthenticatorCallT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CreateAuthenticatorCall::UnPackTo(CreateAuthenticatorCallT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ttyName(); if (_e) _o->ttyName = _e->str(); };
  { auto _e = deviceID(); if (_e) _o->deviceID = _e->str(); };
}

inline flatbuffers::Offset<CreateAuthenticatorCall> CreateAuthenticatorCall::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreateAuthenticatorCallT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCreateAuthenticatorCall(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CreateAuthenticatorCall> CreateCreateAuthenticatorCall(flatbuffers::FlatBufferBuilder &_fbb, const CreateAuthenticatorCallT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CreateAuthenticatorCallT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ttyName = _o->ttyName.empty() ? 0 : _fbb.CreateString(_o->ttyName);
  auto _deviceID = _o->deviceID.empty() ? 0 : _fbb.CreateString(_o->deviceID);
  return nfcdoorz::ipc::api::CreateCreateAuthenticatorCall(
      _fbb,
      _ttyName,
      _deviceID);
}

inline CreateAuthenticatorReplyT *CreateAuthenticatorReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CreateAuthenticatorReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CreateAuthenticatorReply::UnPackTo(CreateAuthenticatorReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = status(); _o->status = _e; };
}

inline flatbuffers::Offset<CreateAuthenticatorReply> CreateAuthenticatorReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreateAuthenticatorReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCreateAuthenticatorReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CreateAuthenticatorReply> CreateCreateAuthenticatorReply(flatbuffers::FlatBufferBuilder &_fbb, const CreateAuthenticatorReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CreateAuthenticatorReplyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _status = _o->status;
  return nfcdoorz::ipc::api::CreateCreateAuthenticatorReply(
      _fbb,
      _status);
}

inline DestroyAuthenticatorCallT *DestroyAuthenticatorCall::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DestroyAuthenticatorCallT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DestroyAuthenticatorCall::UnPackTo(DestroyAuthenticatorCallT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = deviceID(); if (_e) _o->deviceID = _e->str(); };
}

inline flatbuffers::Offset<DestroyAuthenticatorCall> DestroyAuthenticatorCall::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DestroyAuthenticatorCallT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDestroyAuthenticatorCall(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DestroyAuthenticatorCall> CreateDestroyAuthenticatorCall(flatbuffers::FlatBufferBuilder &_fbb, const DestroyAuthenticatorCallT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DestroyAuthenticatorCallT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _deviceID = _o->deviceID.empty() ? 0 : _fbb.CreateString(_o->deviceID);
  return nfcdoorz::ipc::api::CreateDestroyAuthenticatorCall(
      _fbb,
      _deviceID);
}

inline DestroyAuthenticatorReplyT *DestroyAuthenticatorReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DestroyAuthenticatorReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DestroyAuthenticatorReply::UnPackTo(DestroyAuthenticatorReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = status(); _o->status = _e; };
}

inline flatbuffers::Offset<DestroyAuthenticatorReply> DestroyAuthenticatorReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DestroyAuthenticatorReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDestroyAuthenticatorReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DestroyAuthenticatorReply> CreateDestroyAuthenticatorReply(flatbuffers::FlatBufferBuilder &_fbb, const DestroyAuthenticatorReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DestroyAuthenticatorReplyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _status = _o->status;
  return nfcdoorz::ipc::api::CreateDestroyAuthenticatorReply(
      _fbb,
      _status);
}

inline AuthenticatorExitEventT *AuthenticatorExitEvent::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AuthenticatorExitEventT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AuthenticatorExitEvent::UnPackTo(AuthenticatorExitEventT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = deviceID(); if (_e) _o->deviceID = _e->str(); };
}

inline flatbuffers::Offset<AuthenticatorExitEvent> AuthenticatorExitEvent::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticatorExitEventT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAuthenticatorExitEvent(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AuthenticatorExitEvent> CreateAuthenticatorExitEvent(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticatorExitEventT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AuthenticatorExitEventT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _deviceID = _o->deviceID.empty() ? 0 : _fbb.CreateString(_o->deviceID);
  return nfcdoorz::ipc::api::CreateAuthenticatorExitEvent(
      _fbb,
      _deviceID);
}

inline CallT *Call::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CallT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Call::UnPackTo(CallT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = msg_type(); _o->msg.type = _e; };
  { auto _e = msg(); if (_e) _o->msg.value = CallsUnion::UnPack(_e, msg_type(), _resolver); };
}

inline flatbuffers::Offset<Call> Call::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCall(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Call> CreateCall(flatbuffers::FlatBufferBuilder &_fbb, const CallT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CallT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _msg_type = _o->msg.type;
  auto _msg = _o->msg.Pack(_fbb);
  return nfcdoorz::ipc::api::CreateCall(
      _fbb,
      _id,
      _msg_type,
      _msg);
}

inline ReplyT *Reply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply::UnPackTo(ReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = msg_type(); _o->msg.type = _e; };
  { auto _e = msg(); if (_e) _o->msg.value = RepliesUnion::UnPack(_e, msg_type(), _resolver); };
  { auto _e = event_type(); _o->event.type = _e; };
  { auto _e = event(); if (_e) _o->event.value = EventsUnion::UnPack(_e, event_type(), _resolver); };
}

inline flatbuffers::Offset<Reply> Reply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply> CreateReply(flatbuffers::FlatBufferBuilder &_fbb, const ReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReplyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _msg_type = _o->msg.type;
  auto _msg = _o->msg.Pack(_fbb);
  auto _event_type = _o->event.type;
  auto _event = _o->event.Pack(_fbb);
  return nfcdoorz::ipc::api::CreateReply(
      _fbb,
      _id,
      _msg_type,
      _msg,
      _event_type,
      _event);
}

inline ServerT *Server::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ServerT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Server::UnPackTo(ServerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = call(); if (_e) _o->call = std::unique_ptr<CallT>(_e->UnPack(_resolver)); };
  { auto _e = reply(); if (_e) _o->reply = std::unique_ptr<ReplyT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Server> Server::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateServer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Server> CreateServer(flatbuffers::FlatBufferBuilder &_fbb, const ServerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ServerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _call = _o->call ? CreateCall(_fbb, _o->call.get(), _rehasher) : 0;
  auto _reply = _o->reply ? CreateReply(_fbb, _o->reply.get(), _rehasher) : 0;
  return nfcdoorz::ipc::api::CreateServer(
      _fbb,
      _call,
      _reply);
}

inline bool VerifyCalls(flatbuffers::Verifier &verifier, const void *obj, Calls type) {
  switch (type) {
    case Calls::NONE: {
      return true;
    }
    case Calls::StatusCall: {
      auto ptr = reinterpret_cast<const StatusCall *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Calls::CreateAuthenticatorCall: {
      auto ptr = reinterpret_cast<const CreateAuthenticatorCall *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Calls::DestroyAuthenticatorCall: {
      auto ptr = reinterpret_cast<const DestroyAuthenticatorCall *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyCallsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCalls(
        verifier,  values->Get(i), types->GetEnum<Calls>(i))) {
      return false;
    }
  }
  return true;
}

inline void *CallsUnion::UnPack(const void *obj, Calls type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Calls::StatusCall: {
      auto ptr = reinterpret_cast<const StatusCall *>(obj);
      return ptr->UnPack(resolver);
    }
    case Calls::CreateAuthenticatorCall: {
      auto ptr = reinterpret_cast<const CreateAuthenticatorCall *>(obj);
      return ptr->UnPack(resolver);
    }
    case Calls::DestroyAuthenticatorCall: {
      auto ptr = reinterpret_cast<const DestroyAuthenticatorCall *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> CallsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Calls::StatusCall: {
      auto ptr = reinterpret_cast<const StatusCallT *>(value);
      return CreateStatusCall(_fbb, ptr, _rehasher).Union();
    }
    case Calls::CreateAuthenticatorCall: {
      auto ptr = reinterpret_cast<const CreateAuthenticatorCallT *>(value);
      return CreateCreateAuthenticatorCall(_fbb, ptr, _rehasher).Union();
    }
    case Calls::DestroyAuthenticatorCall: {
      auto ptr = reinterpret_cast<const DestroyAuthenticatorCallT *>(value);
      return CreateDestroyAuthenticatorCall(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline CallsUnion::CallsUnion(const CallsUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case Calls::StatusCall: {
      value = new StatusCallT(*reinterpret_cast<StatusCallT *>(u.value));
      break;
    }
    case Calls::CreateAuthenticatorCall: {
      value = new CreateAuthenticatorCallT(*reinterpret_cast<CreateAuthenticatorCallT *>(u.value));
      break;
    }
    case Calls::DestroyAuthenticatorCall: {
      value = new DestroyAuthenticatorCallT(*reinterpret_cast<DestroyAuthenticatorCallT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void CallsUnion::Reset() {
  switch (type) {
    case Calls::StatusCall: {
      auto ptr = reinterpret_cast<StatusCallT *>(value);
      delete ptr;
      break;
    }
    case Calls::CreateAuthenticatorCall: {
      auto ptr = reinterpret_cast<CreateAuthenticatorCallT *>(value);
      delete ptr;
      break;
    }
    case Calls::DestroyAuthenticatorCall: {
      auto ptr = reinterpret_cast<DestroyAuthenticatorCallT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Calls::NONE;
}

inline bool VerifyReplies(flatbuffers::Verifier &verifier, const void *obj, Replies type) {
  switch (type) {
    case Replies::NONE: {
      return true;
    }
    case Replies::StatusReply: {
      auto ptr = reinterpret_cast<const StatusReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Replies::CreateAuthenticatorReply: {
      auto ptr = reinterpret_cast<const CreateAuthenticatorReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Replies::DestroyAuthenticatorReply: {
      auto ptr = reinterpret_cast<const DestroyAuthenticatorReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyRepliesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyReplies(
        verifier,  values->Get(i), types->GetEnum<Replies>(i))) {
      return false;
    }
  }
  return true;
}

inline void *RepliesUnion::UnPack(const void *obj, Replies type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Replies::StatusReply: {
      auto ptr = reinterpret_cast<const StatusReply *>(obj);
      return ptr->UnPack(resolver);
    }
    case Replies::CreateAuthenticatorReply: {
      auto ptr = reinterpret_cast<const CreateAuthenticatorReply *>(obj);
      return ptr->UnPack(resolver);
    }
    case Replies::DestroyAuthenticatorReply: {
      auto ptr = reinterpret_cast<const DestroyAuthenticatorReply *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> RepliesUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Replies::StatusReply: {
      auto ptr = reinterpret_cast<const StatusReplyT *>(value);
      return CreateStatusReply(_fbb, ptr, _rehasher).Union();
    }
    case Replies::CreateAuthenticatorReply: {
      auto ptr = reinterpret_cast<const CreateAuthenticatorReplyT *>(value);
      return CreateCreateAuthenticatorReply(_fbb, ptr, _rehasher).Union();
    }
    case Replies::DestroyAuthenticatorReply: {
      auto ptr = reinterpret_cast<const DestroyAuthenticatorReplyT *>(value);
      return CreateDestroyAuthenticatorReply(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline RepliesUnion::RepliesUnion(const RepliesUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case Replies::StatusReply: {
      FLATBUFFERS_ASSERT(false);  // StatusReplyT not copyable.
      break;
    }
    case Replies::CreateAuthenticatorReply: {
      value = new CreateAuthenticatorReplyT(*reinterpret_cast<CreateAuthenticatorReplyT *>(u.value));
      break;
    }
    case Replies::DestroyAuthenticatorReply: {
      value = new DestroyAuthenticatorReplyT(*reinterpret_cast<DestroyAuthenticatorReplyT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void RepliesUnion::Reset() {
  switch (type) {
    case Replies::StatusReply: {
      auto ptr = reinterpret_cast<StatusReplyT *>(value);
      delete ptr;
      break;
    }
    case Replies::CreateAuthenticatorReply: {
      auto ptr = reinterpret_cast<CreateAuthenticatorReplyT *>(value);
      delete ptr;
      break;
    }
    case Replies::DestroyAuthenticatorReply: {
      auto ptr = reinterpret_cast<DestroyAuthenticatorReplyT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Replies::NONE;
}

inline bool VerifyEvents(flatbuffers::Verifier &verifier, const void *obj, Events type) {
  switch (type) {
    case Events::NONE: {
      return true;
    }
    case Events::AuthenticatorExitEvent: {
      auto ptr = reinterpret_cast<const AuthenticatorExitEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEvents(
        verifier,  values->Get(i), types->GetEnum<Events>(i))) {
      return false;
    }
  }
  return true;
}

inline void *EventsUnion::UnPack(const void *obj, Events type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Events::AuthenticatorExitEvent: {
      auto ptr = reinterpret_cast<const AuthenticatorExitEvent *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> EventsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Events::AuthenticatorExitEvent: {
      auto ptr = reinterpret_cast<const AuthenticatorExitEventT *>(value);
      return CreateAuthenticatorExitEvent(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline EventsUnion::EventsUnion(const EventsUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case Events::AuthenticatorExitEvent: {
      value = new AuthenticatorExitEventT(*reinterpret_cast<AuthenticatorExitEventT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void EventsUnion::Reset() {
  switch (type) {
    case Events::AuthenticatorExitEvent: {
      auto ptr = reinterpret_cast<AuthenticatorExitEventT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Events::NONE;
}

inline const flatbuffers::TypeTable *CallsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    StatusCallTypeTable,
    CreateAuthenticatorCallTypeTable,
    DestroyAuthenticatorCallTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "StatusCall",
    "CreateAuthenticatorCall",
    "DestroyAuthenticatorCall"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RepliesTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    StatusReplyTypeTable,
    CreateAuthenticatorReplyTypeTable,
    DestroyAuthenticatorReplyTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "StatusReply",
    "CreateAuthenticatorReply",
    "DestroyAuthenticatorReply"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EventsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AuthenticatorExitEventTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "AuthenticatorExitEvent"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StatusCallTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ProcessTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 1, -1 }
  };
  static const char * const names[] = {
    "pid",
    "name",
    "args"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StatusReplyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ProcessTypeTable
  };
  static const char * const names[] = {
    "processes"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CreateAuthenticatorCallTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "ttyName",
    "deviceID"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CreateAuthenticatorReplyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "status"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DestroyAuthenticatorCallTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "deviceID"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DestroyAuthenticatorReplyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "status"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AuthenticatorExitEventTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "deviceID"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CallTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    CallsTypeTable
  };
  static const char * const names[] = {
    "id",
    "msg_type",
    "msg"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReplyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_UTYPE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    RepliesTypeTable,
    EventsTypeTable
  };
  static const char * const names[] = {
    "id",
    "msg_type",
    "msg",
    "event_type",
    "event"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ServerTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    CallTypeTable,
    ReplyTypeTable
  };
  static const char * const names[] = {
    "call",
    "reply"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

}  // namespace api
}  // namespace ipc
}  // namespace nfcdoorz

#endif  // FLATBUFFERS_GENERATED_IPCAPI_NFCDOORZ_IPC_API_H_
