// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_IPCAPI_NFCDOORZ_IPC_API_H_
#define FLATBUFFERS_GENERATED_IPCAPI_NFCDOORZ_IPC_API_H_

#include "flatbuffers/flatbuffers.h"

namespace nfcdoorz {
namespace ipc {
namespace api {

struct StatusCall;
struct StatusCallT;

struct Process;
struct ProcessT;

struct StatusReply;
struct StatusReplyT;

struct CreateAuthenticatorCall;
struct CreateAuthenticatorCallT;

struct CreateAuthenticatorReply;
struct CreateAuthenticatorReplyT;

struct DestroyAuthenticatorCall;
struct DestroyAuthenticatorCallT;

struct DestroyAuthenticatorReply;
struct DestroyAuthenticatorReplyT;

struct AuthenticatorExitEvent;
struct AuthenticatorExitEventT;

struct APICall;
struct APICallT;

struct APIReply;
struct APIReplyT;

struct Server;
struct ServerT;

inline const flatbuffers::TypeTable *StatusCallTypeTable();

inline const flatbuffers::TypeTable *ProcessTypeTable();

inline const flatbuffers::TypeTable *StatusReplyTypeTable();

inline const flatbuffers::TypeTable *CreateAuthenticatorCallTypeTable();

inline const flatbuffers::TypeTable *CreateAuthenticatorReplyTypeTable();

inline const flatbuffers::TypeTable *DestroyAuthenticatorCallTypeTable();

inline const flatbuffers::TypeTable *DestroyAuthenticatorReplyTypeTable();

inline const flatbuffers::TypeTable *AuthenticatorExitEventTypeTable();

inline const flatbuffers::TypeTable *APICallTypeTable();

inline const flatbuffers::TypeTable *APIReplyTypeTable();

inline const flatbuffers::TypeTable *ServerTypeTable();

enum class APICalls : uint8_t {
  NONE = 0,
  StatusCall = 1,
  CreateAuthenticatorCall = 2,
  DestroyAuthenticatorCall = 3,
  MIN = NONE,
  MAX = DestroyAuthenticatorCall
};

inline const APICalls (&EnumValuesAPICalls())[4] {
  static const APICalls values[] = {
    APICalls::NONE,
    APICalls::StatusCall,
    APICalls::CreateAuthenticatorCall,
    APICalls::DestroyAuthenticatorCall
  };
  return values;
}

inline const char * const *EnumNamesAPICalls() {
  static const char * const names[] = {
    "NONE",
    "StatusCall",
    "CreateAuthenticatorCall",
    "DestroyAuthenticatorCall",
    nullptr
  };
  return names;
}

inline const char *EnumNameAPICalls(APICalls e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAPICalls()[index];
}

template<typename T> struct APICallsTraits {
  static const APICalls enum_value = APICalls::NONE;
};

template<> struct APICallsTraits<StatusCall> {
  static const APICalls enum_value = APICalls::StatusCall;
};

template<> struct APICallsTraits<CreateAuthenticatorCall> {
  static const APICalls enum_value = APICalls::CreateAuthenticatorCall;
};

template<> struct APICallsTraits<DestroyAuthenticatorCall> {
  static const APICalls enum_value = APICalls::DestroyAuthenticatorCall;
};

struct APICallsUnion {
  APICalls type;
  void *value;

  APICallsUnion() : type(APICalls::NONE), value(nullptr) {}
  APICallsUnion(APICallsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(APICalls::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  APICallsUnion(const APICallsUnion &) FLATBUFFERS_NOEXCEPT;
  APICallsUnion &operator=(const APICallsUnion &u) FLATBUFFERS_NOEXCEPT
    { APICallsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  APICallsUnion &operator=(APICallsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~APICallsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = APICallsTraits<typename T::TableType>::enum_value;
    if (type != APICalls::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, APICalls type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  StatusCallT *AsStatusCall() {
    return type == APICalls::StatusCall ?
      reinterpret_cast<StatusCallT *>(value) : nullptr;
  }
  const StatusCallT *AsStatusCall() const {
    return type == APICalls::StatusCall ?
      reinterpret_cast<const StatusCallT *>(value) : nullptr;
  }
  CreateAuthenticatorCallT *AsCreateAuthenticatorCall() {
    return type == APICalls::CreateAuthenticatorCall ?
      reinterpret_cast<CreateAuthenticatorCallT *>(value) : nullptr;
  }
  const CreateAuthenticatorCallT *AsCreateAuthenticatorCall() const {
    return type == APICalls::CreateAuthenticatorCall ?
      reinterpret_cast<const CreateAuthenticatorCallT *>(value) : nullptr;
  }
  DestroyAuthenticatorCallT *AsDestroyAuthenticatorCall() {
    return type == APICalls::DestroyAuthenticatorCall ?
      reinterpret_cast<DestroyAuthenticatorCallT *>(value) : nullptr;
  }
  const DestroyAuthenticatorCallT *AsDestroyAuthenticatorCall() const {
    return type == APICalls::DestroyAuthenticatorCall ?
      reinterpret_cast<const DestroyAuthenticatorCallT *>(value) : nullptr;
  }
};

bool VerifyAPICalls(flatbuffers::Verifier &verifier, const void *obj, APICalls type);
bool VerifyAPICallsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class APIReplies : uint8_t {
  NONE = 0,
  StatusReply = 1,
  CreateAuthenticatorReply = 2,
  DestroyAuthenticatorReply = 3,
  MIN = NONE,
  MAX = DestroyAuthenticatorReply
};

inline const APIReplies (&EnumValuesAPIReplies())[4] {
  static const APIReplies values[] = {
    APIReplies::NONE,
    APIReplies::StatusReply,
    APIReplies::CreateAuthenticatorReply,
    APIReplies::DestroyAuthenticatorReply
  };
  return values;
}

inline const char * const *EnumNamesAPIReplies() {
  static const char * const names[] = {
    "NONE",
    "StatusReply",
    "CreateAuthenticatorReply",
    "DestroyAuthenticatorReply",
    nullptr
  };
  return names;
}

inline const char *EnumNameAPIReplies(APIReplies e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAPIReplies()[index];
}

template<typename T> struct APIRepliesTraits {
  static const APIReplies enum_value = APIReplies::NONE;
};

template<> struct APIRepliesTraits<StatusReply> {
  static const APIReplies enum_value = APIReplies::StatusReply;
};

template<> struct APIRepliesTraits<CreateAuthenticatorReply> {
  static const APIReplies enum_value = APIReplies::CreateAuthenticatorReply;
};

template<> struct APIRepliesTraits<DestroyAuthenticatorReply> {
  static const APIReplies enum_value = APIReplies::DestroyAuthenticatorReply;
};

struct APIRepliesUnion {
  APIReplies type;
  void *value;

  APIRepliesUnion() : type(APIReplies::NONE), value(nullptr) {}
  APIRepliesUnion(APIRepliesUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(APIReplies::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  APIRepliesUnion(const APIRepliesUnion &) FLATBUFFERS_NOEXCEPT;
  APIRepliesUnion &operator=(const APIRepliesUnion &u) FLATBUFFERS_NOEXCEPT
    { APIRepliesUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  APIRepliesUnion &operator=(APIRepliesUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~APIRepliesUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = APIRepliesTraits<typename T::TableType>::enum_value;
    if (type != APIReplies::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, APIReplies type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  StatusReplyT *AsStatusReply() {
    return type == APIReplies::StatusReply ?
      reinterpret_cast<StatusReplyT *>(value) : nullptr;
  }
  const StatusReplyT *AsStatusReply() const {
    return type == APIReplies::StatusReply ?
      reinterpret_cast<const StatusReplyT *>(value) : nullptr;
  }
  CreateAuthenticatorReplyT *AsCreateAuthenticatorReply() {
    return type == APIReplies::CreateAuthenticatorReply ?
      reinterpret_cast<CreateAuthenticatorReplyT *>(value) : nullptr;
  }
  const CreateAuthenticatorReplyT *AsCreateAuthenticatorReply() const {
    return type == APIReplies::CreateAuthenticatorReply ?
      reinterpret_cast<const CreateAuthenticatorReplyT *>(value) : nullptr;
  }
  DestroyAuthenticatorReplyT *AsDestroyAuthenticatorReply() {
    return type == APIReplies::DestroyAuthenticatorReply ?
      reinterpret_cast<DestroyAuthenticatorReplyT *>(value) : nullptr;
  }
  const DestroyAuthenticatorReplyT *AsDestroyAuthenticatorReply() const {
    return type == APIReplies::DestroyAuthenticatorReply ?
      reinterpret_cast<const DestroyAuthenticatorReplyT *>(value) : nullptr;
  }
};

bool VerifyAPIReplies(flatbuffers::Verifier &verifier, const void *obj, APIReplies type);
bool VerifyAPIRepliesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class APIEvents : uint8_t {
  NONE = 0,
  AuthenticatorExitEvent = 1,
  MIN = NONE,
  MAX = AuthenticatorExitEvent
};

inline const APIEvents (&EnumValuesAPIEvents())[2] {
  static const APIEvents values[] = {
    APIEvents::NONE,
    APIEvents::AuthenticatorExitEvent
  };
  return values;
}

inline const char * const *EnumNamesAPIEvents() {
  static const char * const names[] = {
    "NONE",
    "AuthenticatorExitEvent",
    nullptr
  };
  return names;
}

inline const char *EnumNameAPIEvents(APIEvents e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAPIEvents()[index];
}

template<typename T> struct APIEventsTraits {
  static const APIEvents enum_value = APIEvents::NONE;
};

template<> struct APIEventsTraits<AuthenticatorExitEvent> {
  static const APIEvents enum_value = APIEvents::AuthenticatorExitEvent;
};

struct APIEventsUnion {
  APIEvents type;
  void *value;

  APIEventsUnion() : type(APIEvents::NONE), value(nullptr) {}
  APIEventsUnion(APIEventsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(APIEvents::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  APIEventsUnion(const APIEventsUnion &) FLATBUFFERS_NOEXCEPT;
  APIEventsUnion &operator=(const APIEventsUnion &u) FLATBUFFERS_NOEXCEPT
    { APIEventsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  APIEventsUnion &operator=(APIEventsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~APIEventsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = APIEventsTraits<typename T::TableType>::enum_value;
    if (type != APIEvents::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, APIEvents type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  AuthenticatorExitEventT *AsAuthenticatorExitEvent() {
    return type == APIEvents::AuthenticatorExitEvent ?
      reinterpret_cast<AuthenticatorExitEventT *>(value) : nullptr;
  }
  const AuthenticatorExitEventT *AsAuthenticatorExitEvent() const {
    return type == APIEvents::AuthenticatorExitEvent ?
      reinterpret_cast<const AuthenticatorExitEventT *>(value) : nullptr;
  }
};

bool VerifyAPIEvents(flatbuffers::Verifier &verifier, const void *obj, APIEvents type);
bool VerifyAPIEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct StatusCallT : public flatbuffers::NativeTable {
  typedef StatusCall TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.StatusCallT";
  }
  StatusCallT() {
  }
};

struct StatusCall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatusCallT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StatusCallTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.StatusCall";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  StatusCallT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StatusCallT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StatusCall> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StatusCallT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StatusCallBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit StatusCallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StatusCallBuilder &operator=(const StatusCallBuilder &);
  flatbuffers::Offset<StatusCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatusCall>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatusCall> CreateStatusCall(
    flatbuffers::FlatBufferBuilder &_fbb) {
  StatusCallBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<StatusCall> CreateStatusCall(flatbuffers::FlatBufferBuilder &_fbb, const StatusCallT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProcessT : public flatbuffers::NativeTable {
  typedef Process TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.ProcessT";
  }
  int32_t pid;
  std::string name;
  std::vector<std::string> args;
  ProcessT()
      : pid(0) {
  }
};

struct Process FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProcessT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ProcessTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.Process";
  }
  enum {
    VT_PID = 4,
    VT_NAME = 6,
    VT_ARGS = 8
  };
  int32_t pid() const {
    return GetField<int32_t>(VT_PID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *args() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ARGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_ARGS) &&
           verifier.VerifyVector(args()) &&
           verifier.VerifyVectorOfStrings(args()) &&
           verifier.EndTable();
  }
  ProcessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProcessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Process> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProcessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProcessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pid(int32_t pid) {
    fbb_.AddElement<int32_t>(Process::VT_PID, pid, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Process::VT_NAME, name);
  }
  void add_args(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> args) {
    fbb_.AddOffset(Process::VT_ARGS, args);
  }
  explicit ProcessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProcessBuilder &operator=(const ProcessBuilder &);
  flatbuffers::Offset<Process> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Process>(end);
    return o;
  }
};

inline flatbuffers::Offset<Process> CreateProcess(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pid = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> args = 0) {
  ProcessBuilder builder_(_fbb);
  builder_.add_args(args);
  builder_.add_name(name);
  builder_.add_pid(pid);
  return builder_.Finish();
}

inline flatbuffers::Offset<Process> CreateProcessDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pid = 0,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *args = nullptr) {
  return nfcdoorz::ipc::api::CreateProcess(
      _fbb,
      pid,
      name ? _fbb.CreateString(name) : 0,
      args ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*args) : 0);
}

flatbuffers::Offset<Process> CreateProcess(flatbuffers::FlatBufferBuilder &_fbb, const ProcessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StatusReplyT : public flatbuffers::NativeTable {
  typedef StatusReply TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.StatusReplyT";
  }
  std::vector<std::unique_ptr<ProcessT>> processes;
  StatusReplyT() {
  }
};

struct StatusReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatusReplyT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StatusReplyTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.StatusReply";
  }
  enum {
    VT_PROCESSES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Process>> *processes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Process>> *>(VT_PROCESSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROCESSES) &&
           verifier.VerifyVector(processes()) &&
           verifier.VerifyVectorOfTables(processes()) &&
           verifier.EndTable();
  }
  StatusReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StatusReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StatusReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StatusReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StatusReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_processes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Process>>> processes) {
    fbb_.AddOffset(StatusReply::VT_PROCESSES, processes);
  }
  explicit StatusReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StatusReplyBuilder &operator=(const StatusReplyBuilder &);
  flatbuffers::Offset<StatusReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatusReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatusReply> CreateStatusReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Process>>> processes = 0) {
  StatusReplyBuilder builder_(_fbb);
  builder_.add_processes(processes);
  return builder_.Finish();
}

inline flatbuffers::Offset<StatusReply> CreateStatusReplyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Process>> *processes = nullptr) {
  return nfcdoorz::ipc::api::CreateStatusReply(
      _fbb,
      processes ? _fbb.CreateVector<flatbuffers::Offset<Process>>(*processes) : 0);
}

flatbuffers::Offset<StatusReply> CreateStatusReply(flatbuffers::FlatBufferBuilder &_fbb, const StatusReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CreateAuthenticatorCallT : public flatbuffers::NativeTable {
  typedef CreateAuthenticatorCall TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.CreateAuthenticatorCallT";
  }
  std::string ttyName;
  std::string deviceID;
  CreateAuthenticatorCallT() {
  }
};

struct CreateAuthenticatorCall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreateAuthenticatorCallT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CreateAuthenticatorCallTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.CreateAuthenticatorCall";
  }
  enum {
    VT_TTYNAME = 4,
    VT_DEVICEID = 6
  };
  const flatbuffers::String *ttyName() const {
    return GetPointer<const flatbuffers::String *>(VT_TTYNAME);
  }
  const flatbuffers::String *deviceID() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TTYNAME) &&
           verifier.VerifyString(ttyName()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.VerifyString(deviceID()) &&
           verifier.EndTable();
  }
  CreateAuthenticatorCallT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CreateAuthenticatorCallT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CreateAuthenticatorCall> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreateAuthenticatorCallT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CreateAuthenticatorCallBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ttyName(flatbuffers::Offset<flatbuffers::String> ttyName) {
    fbb_.AddOffset(CreateAuthenticatorCall::VT_TTYNAME, ttyName);
  }
  void add_deviceID(flatbuffers::Offset<flatbuffers::String> deviceID) {
    fbb_.AddOffset(CreateAuthenticatorCall::VT_DEVICEID, deviceID);
  }
  explicit CreateAuthenticatorCallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CreateAuthenticatorCallBuilder &operator=(const CreateAuthenticatorCallBuilder &);
  flatbuffers::Offset<CreateAuthenticatorCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CreateAuthenticatorCall>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreateAuthenticatorCall> CreateCreateAuthenticatorCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ttyName = 0,
    flatbuffers::Offset<flatbuffers::String> deviceID = 0) {
  CreateAuthenticatorCallBuilder builder_(_fbb);
  builder_.add_deviceID(deviceID);
  builder_.add_ttyName(ttyName);
  return builder_.Finish();
}

inline flatbuffers::Offset<CreateAuthenticatorCall> CreateCreateAuthenticatorCallDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ttyName = nullptr,
    const char *deviceID = nullptr) {
  return nfcdoorz::ipc::api::CreateCreateAuthenticatorCall(
      _fbb,
      ttyName ? _fbb.CreateString(ttyName) : 0,
      deviceID ? _fbb.CreateString(deviceID) : 0);
}

flatbuffers::Offset<CreateAuthenticatorCall> CreateCreateAuthenticatorCall(flatbuffers::FlatBufferBuilder &_fbb, const CreateAuthenticatorCallT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CreateAuthenticatorReplyT : public flatbuffers::NativeTable {
  typedef CreateAuthenticatorReply TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.CreateAuthenticatorReplyT";
  }
  bool status;
  CreateAuthenticatorReplyT()
      : status(false) {
  }
};

struct CreateAuthenticatorReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreateAuthenticatorReplyT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CreateAuthenticatorReplyTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.CreateAuthenticatorReply";
  }
  enum {
    VT_STATUS = 4
  };
  bool status() const {
    return GetField<uint8_t>(VT_STATUS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           verifier.EndTable();
  }
  CreateAuthenticatorReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CreateAuthenticatorReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CreateAuthenticatorReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreateAuthenticatorReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CreateAuthenticatorReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(bool status) {
    fbb_.AddElement<uint8_t>(CreateAuthenticatorReply::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  explicit CreateAuthenticatorReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CreateAuthenticatorReplyBuilder &operator=(const CreateAuthenticatorReplyBuilder &);
  flatbuffers::Offset<CreateAuthenticatorReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CreateAuthenticatorReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreateAuthenticatorReply> CreateCreateAuthenticatorReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool status = false) {
  CreateAuthenticatorReplyBuilder builder_(_fbb);
  builder_.add_status(status);
  return builder_.Finish();
}

flatbuffers::Offset<CreateAuthenticatorReply> CreateCreateAuthenticatorReply(flatbuffers::FlatBufferBuilder &_fbb, const CreateAuthenticatorReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DestroyAuthenticatorCallT : public flatbuffers::NativeTable {
  typedef DestroyAuthenticatorCall TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.DestroyAuthenticatorCallT";
  }
  std::string deviceID;
  DestroyAuthenticatorCallT() {
  }
};

struct DestroyAuthenticatorCall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DestroyAuthenticatorCallT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DestroyAuthenticatorCallTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.DestroyAuthenticatorCall";
  }
  enum {
    VT_DEVICEID = 4
  };
  const flatbuffers::String *deviceID() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.VerifyString(deviceID()) &&
           verifier.EndTable();
  }
  DestroyAuthenticatorCallT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DestroyAuthenticatorCallT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DestroyAuthenticatorCall> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DestroyAuthenticatorCallT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DestroyAuthenticatorCallBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deviceID(flatbuffers::Offset<flatbuffers::String> deviceID) {
    fbb_.AddOffset(DestroyAuthenticatorCall::VT_DEVICEID, deviceID);
  }
  explicit DestroyAuthenticatorCallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DestroyAuthenticatorCallBuilder &operator=(const DestroyAuthenticatorCallBuilder &);
  flatbuffers::Offset<DestroyAuthenticatorCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DestroyAuthenticatorCall>(end);
    return o;
  }
};

inline flatbuffers::Offset<DestroyAuthenticatorCall> CreateDestroyAuthenticatorCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> deviceID = 0) {
  DestroyAuthenticatorCallBuilder builder_(_fbb);
  builder_.add_deviceID(deviceID);
  return builder_.Finish();
}

inline flatbuffers::Offset<DestroyAuthenticatorCall> CreateDestroyAuthenticatorCallDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *deviceID = nullptr) {
  return nfcdoorz::ipc::api::CreateDestroyAuthenticatorCall(
      _fbb,
      deviceID ? _fbb.CreateString(deviceID) : 0);
}

flatbuffers::Offset<DestroyAuthenticatorCall> CreateDestroyAuthenticatorCall(flatbuffers::FlatBufferBuilder &_fbb, const DestroyAuthenticatorCallT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DestroyAuthenticatorReplyT : public flatbuffers::NativeTable {
  typedef DestroyAuthenticatorReply TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.DestroyAuthenticatorReplyT";
  }
  bool status;
  DestroyAuthenticatorReplyT()
      : status(false) {
  }
};

struct DestroyAuthenticatorReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DestroyAuthenticatorReplyT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DestroyAuthenticatorReplyTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.DestroyAuthenticatorReply";
  }
  enum {
    VT_STATUS = 4
  };
  bool status() const {
    return GetField<uint8_t>(VT_STATUS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           verifier.EndTable();
  }
  DestroyAuthenticatorReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DestroyAuthenticatorReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DestroyAuthenticatorReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DestroyAuthenticatorReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DestroyAuthenticatorReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(bool status) {
    fbb_.AddElement<uint8_t>(DestroyAuthenticatorReply::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  explicit DestroyAuthenticatorReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DestroyAuthenticatorReplyBuilder &operator=(const DestroyAuthenticatorReplyBuilder &);
  flatbuffers::Offset<DestroyAuthenticatorReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DestroyAuthenticatorReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<DestroyAuthenticatorReply> CreateDestroyAuthenticatorReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool status = false) {
  DestroyAuthenticatorReplyBuilder builder_(_fbb);
  builder_.add_status(status);
  return builder_.Finish();
}

flatbuffers::Offset<DestroyAuthenticatorReply> CreateDestroyAuthenticatorReply(flatbuffers::FlatBufferBuilder &_fbb, const DestroyAuthenticatorReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthenticatorExitEventT : public flatbuffers::NativeTable {
  typedef AuthenticatorExitEvent TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.AuthenticatorExitEventT";
  }
  std::string deviceID;
  AuthenticatorExitEventT() {
  }
};

struct AuthenticatorExitEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AuthenticatorExitEventT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AuthenticatorExitEventTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.AuthenticatorExitEvent";
  }
  enum {
    VT_DEVICEID = 4
  };
  const flatbuffers::String *deviceID() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.VerifyString(deviceID()) &&
           verifier.EndTable();
  }
  AuthenticatorExitEventT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AuthenticatorExitEventT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AuthenticatorExitEvent> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticatorExitEventT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AuthenticatorExitEventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deviceID(flatbuffers::Offset<flatbuffers::String> deviceID) {
    fbb_.AddOffset(AuthenticatorExitEvent::VT_DEVICEID, deviceID);
  }
  explicit AuthenticatorExitEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AuthenticatorExitEventBuilder &operator=(const AuthenticatorExitEventBuilder &);
  flatbuffers::Offset<AuthenticatorExitEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AuthenticatorExitEvent>(end);
    return o;
  }
};

inline flatbuffers::Offset<AuthenticatorExitEvent> CreateAuthenticatorExitEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> deviceID = 0) {
  AuthenticatorExitEventBuilder builder_(_fbb);
  builder_.add_deviceID(deviceID);
  return builder_.Finish();
}

inline flatbuffers::Offset<AuthenticatorExitEvent> CreateAuthenticatorExitEventDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *deviceID = nullptr) {
  return nfcdoorz::ipc::api::CreateAuthenticatorExitEvent(
      _fbb,
      deviceID ? _fbb.CreateString(deviceID) : 0);
}

flatbuffers::Offset<AuthenticatorExitEvent> CreateAuthenticatorExitEvent(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticatorExitEventT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct APICallT : public flatbuffers::NativeTable {
  typedef APICall TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.APICallT";
  }
  uint64_t id;
  APICallsUnion msg;
  APICallT()
      : id(0) {
  }
};

struct APICall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef APICallT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return APICallTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.APICall";
  }
  enum {
    VT_ID = 4,
    VT_MSG_TYPE = 6,
    VT_MSG = 8
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  APICalls msg_type() const {
    return static_cast<APICalls>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const StatusCall *msg_as_StatusCall() const {
    return msg_type() == APICalls::StatusCall ? static_cast<const StatusCall *>(msg()) : nullptr;
  }
  const CreateAuthenticatorCall *msg_as_CreateAuthenticatorCall() const {
    return msg_type() == APICalls::CreateAuthenticatorCall ? static_cast<const CreateAuthenticatorCall *>(msg()) : nullptr;
  }
  const DestroyAuthenticatorCall *msg_as_DestroyAuthenticatorCall() const {
    return msg_type() == APICalls::DestroyAuthenticatorCall ? static_cast<const DestroyAuthenticatorCall *>(msg()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyAPICalls(verifier, msg(), msg_type()) &&
           verifier.EndTable();
  }
  APICallT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(APICallT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<APICall> Pack(flatbuffers::FlatBufferBuilder &_fbb, const APICallT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const StatusCall *APICall::msg_as<StatusCall>() const {
  return msg_as_StatusCall();
}

template<> inline const CreateAuthenticatorCall *APICall::msg_as<CreateAuthenticatorCall>() const {
  return msg_as_CreateAuthenticatorCall();
}

template<> inline const DestroyAuthenticatorCall *APICall::msg_as<DestroyAuthenticatorCall>() const {
  return msg_as_DestroyAuthenticatorCall();
}

struct APICallBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(APICall::VT_ID, id, 0);
  }
  void add_msg_type(APICalls msg_type) {
    fbb_.AddElement<uint8_t>(APICall::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(APICall::VT_MSG, msg);
  }
  explicit APICallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  APICallBuilder &operator=(const APICallBuilder &);
  flatbuffers::Offset<APICall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<APICall>(end);
    return o;
  }
};

inline flatbuffers::Offset<APICall> CreateAPICall(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    APICalls msg_type = APICalls::NONE,
    flatbuffers::Offset<void> msg = 0) {
  APICallBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

flatbuffers::Offset<APICall> CreateAPICall(flatbuffers::FlatBufferBuilder &_fbb, const APICallT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct APIReplyT : public flatbuffers::NativeTable {
  typedef APIReply TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.APIReplyT";
  }
  uint64_t id;
  APIRepliesUnion msg;
  APIEventsUnion event;
  APIReplyT()
      : id(0) {
  }
};

struct APIReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef APIReplyT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return APIReplyTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.APIReply";
  }
  enum {
    VT_ID = 4,
    VT_MSG_TYPE = 6,
    VT_MSG = 8,
    VT_EVENT_TYPE = 10,
    VT_EVENT = 12
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  APIReplies msg_type() const {
    return static_cast<APIReplies>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const StatusReply *msg_as_StatusReply() const {
    return msg_type() == APIReplies::StatusReply ? static_cast<const StatusReply *>(msg()) : nullptr;
  }
  const CreateAuthenticatorReply *msg_as_CreateAuthenticatorReply() const {
    return msg_type() == APIReplies::CreateAuthenticatorReply ? static_cast<const CreateAuthenticatorReply *>(msg()) : nullptr;
  }
  const DestroyAuthenticatorReply *msg_as_DestroyAuthenticatorReply() const {
    return msg_type() == APIReplies::DestroyAuthenticatorReply ? static_cast<const DestroyAuthenticatorReply *>(msg()) : nullptr;
  }
  APIEvents event_type() const {
    return static_cast<APIEvents>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  template<typename T> const T *event_as() const;
  const AuthenticatorExitEvent *event_as_AuthenticatorExitEvent() const {
    return event_type() == APIEvents::AuthenticatorExitEvent ? static_cast<const AuthenticatorExitEvent *>(event()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyAPIReplies(verifier, msg(), msg_type()) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE) &&
           VerifyOffset(verifier, VT_EVENT) &&
           VerifyAPIEvents(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
  APIReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(APIReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<APIReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const APIReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const StatusReply *APIReply::msg_as<StatusReply>() const {
  return msg_as_StatusReply();
}

template<> inline const CreateAuthenticatorReply *APIReply::msg_as<CreateAuthenticatorReply>() const {
  return msg_as_CreateAuthenticatorReply();
}

template<> inline const DestroyAuthenticatorReply *APIReply::msg_as<DestroyAuthenticatorReply>() const {
  return msg_as_DestroyAuthenticatorReply();
}

template<> inline const AuthenticatorExitEvent *APIReply::event_as<AuthenticatorExitEvent>() const {
  return event_as_AuthenticatorExitEvent();
}

struct APIReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(APIReply::VT_ID, id, 0);
  }
  void add_msg_type(APIReplies msg_type) {
    fbb_.AddElement<uint8_t>(APIReply::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(APIReply::VT_MSG, msg);
  }
  void add_event_type(APIEvents event_type) {
    fbb_.AddElement<uint8_t>(APIReply::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(flatbuffers::Offset<void> event) {
    fbb_.AddOffset(APIReply::VT_EVENT, event);
  }
  explicit APIReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  APIReplyBuilder &operator=(const APIReplyBuilder &);
  flatbuffers::Offset<APIReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<APIReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<APIReply> CreateAPIReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    APIReplies msg_type = APIReplies::NONE,
    flatbuffers::Offset<void> msg = 0,
    APIEvents event_type = APIEvents::NONE,
    flatbuffers::Offset<void> event = 0) {
  APIReplyBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_event(event);
  builder_.add_msg(msg);
  builder_.add_event_type(event_type);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

flatbuffers::Offset<APIReply> CreateAPIReply(flatbuffers::FlatBufferBuilder &_fbb, const APIReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ServerT : public flatbuffers::NativeTable {
  typedef Server TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.ServerT";
  }
  std::unique_ptr<APICallT> call;
  std::unique_ptr<APIReplyT> reply;
  ServerT() {
  }
};

struct Server FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ServerTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.api.Server";
  }
  enum {
    VT_CALL = 4,
    VT_REPLY = 6
  };
  const APICall *call() const {
    return GetPointer<const APICall *>(VT_CALL);
  }
  const APIReply *reply() const {
    return GetPointer<const APIReply *>(VT_REPLY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CALL) &&
           verifier.VerifyTable(call()) &&
           VerifyOffset(verifier, VT_REPLY) &&
           verifier.VerifyTable(reply()) &&
           verifier.EndTable();
  }
  ServerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ServerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Server> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ServerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_call(flatbuffers::Offset<APICall> call) {
    fbb_.AddOffset(Server::VT_CALL, call);
  }
  void add_reply(flatbuffers::Offset<APIReply> reply) {
    fbb_.AddOffset(Server::VT_REPLY, reply);
  }
  explicit ServerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerBuilder &operator=(const ServerBuilder &);
  flatbuffers::Offset<Server> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Server>(end);
    return o;
  }
};

inline flatbuffers::Offset<Server> CreateServer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<APICall> call = 0,
    flatbuffers::Offset<APIReply> reply = 0) {
  ServerBuilder builder_(_fbb);
  builder_.add_reply(reply);
  builder_.add_call(call);
  return builder_.Finish();
}

flatbuffers::Offset<Server> CreateServer(flatbuffers::FlatBufferBuilder &_fbb, const ServerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline StatusCallT *StatusCall::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StatusCallT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StatusCall::UnPackTo(StatusCallT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<StatusCall> StatusCall::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StatusCallT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStatusCall(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StatusCall> CreateStatusCall(flatbuffers::FlatBufferBuilder &_fbb, const StatusCallT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StatusCallT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return nfcdoorz::ipc::api::CreateStatusCall(
      _fbb);
}

inline ProcessT *Process::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ProcessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Process::UnPackTo(ProcessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pid(); _o->pid = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = args(); if (_e) { _o->args.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->args[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<Process> Process::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProcessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProcess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Process> CreateProcess(flatbuffers::FlatBufferBuilder &_fbb, const ProcessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProcessT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pid = _o->pid;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _args = _o->args.size() ? _fbb.CreateVectorOfStrings(_o->args) : 0;
  return nfcdoorz::ipc::api::CreateProcess(
      _fbb,
      _pid,
      _name,
      _args);
}

inline StatusReplyT *StatusReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StatusReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StatusReply::UnPackTo(StatusReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = processes(); if (_e) { _o->processes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->processes[_i] = std::unique_ptr<ProcessT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<StatusReply> StatusReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StatusReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStatusReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StatusReply> CreateStatusReply(flatbuffers::FlatBufferBuilder &_fbb, const StatusReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StatusReplyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _processes = _o->processes.size() ? _fbb.CreateVector<flatbuffers::Offset<Process>> (_o->processes.size(), [](size_t i, _VectorArgs *__va) { return CreateProcess(*__va->__fbb, __va->__o->processes[i].get(), __va->__rehasher); }, &_va ) : 0;
  return nfcdoorz::ipc::api::CreateStatusReply(
      _fbb,
      _processes);
}

inline CreateAuthenticatorCallT *CreateAuthenticatorCall::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CreateAuthenticatorCallT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CreateAuthenticatorCall::UnPackTo(CreateAuthenticatorCallT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ttyName(); if (_e) _o->ttyName = _e->str(); };
  { auto _e = deviceID(); if (_e) _o->deviceID = _e->str(); };
}

inline flatbuffers::Offset<CreateAuthenticatorCall> CreateAuthenticatorCall::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreateAuthenticatorCallT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCreateAuthenticatorCall(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CreateAuthenticatorCall> CreateCreateAuthenticatorCall(flatbuffers::FlatBufferBuilder &_fbb, const CreateAuthenticatorCallT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CreateAuthenticatorCallT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ttyName = _o->ttyName.empty() ? 0 : _fbb.CreateString(_o->ttyName);
  auto _deviceID = _o->deviceID.empty() ? 0 : _fbb.CreateString(_o->deviceID);
  return nfcdoorz::ipc::api::CreateCreateAuthenticatorCall(
      _fbb,
      _ttyName,
      _deviceID);
}

inline CreateAuthenticatorReplyT *CreateAuthenticatorReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CreateAuthenticatorReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CreateAuthenticatorReply::UnPackTo(CreateAuthenticatorReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = status(); _o->status = _e; };
}

inline flatbuffers::Offset<CreateAuthenticatorReply> CreateAuthenticatorReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreateAuthenticatorReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCreateAuthenticatorReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CreateAuthenticatorReply> CreateCreateAuthenticatorReply(flatbuffers::FlatBufferBuilder &_fbb, const CreateAuthenticatorReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CreateAuthenticatorReplyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _status = _o->status;
  return nfcdoorz::ipc::api::CreateCreateAuthenticatorReply(
      _fbb,
      _status);
}

inline DestroyAuthenticatorCallT *DestroyAuthenticatorCall::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DestroyAuthenticatorCallT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DestroyAuthenticatorCall::UnPackTo(DestroyAuthenticatorCallT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = deviceID(); if (_e) _o->deviceID = _e->str(); };
}

inline flatbuffers::Offset<DestroyAuthenticatorCall> DestroyAuthenticatorCall::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DestroyAuthenticatorCallT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDestroyAuthenticatorCall(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DestroyAuthenticatorCall> CreateDestroyAuthenticatorCall(flatbuffers::FlatBufferBuilder &_fbb, const DestroyAuthenticatorCallT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DestroyAuthenticatorCallT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _deviceID = _o->deviceID.empty() ? 0 : _fbb.CreateString(_o->deviceID);
  return nfcdoorz::ipc::api::CreateDestroyAuthenticatorCall(
      _fbb,
      _deviceID);
}

inline DestroyAuthenticatorReplyT *DestroyAuthenticatorReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DestroyAuthenticatorReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DestroyAuthenticatorReply::UnPackTo(DestroyAuthenticatorReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = status(); _o->status = _e; };
}

inline flatbuffers::Offset<DestroyAuthenticatorReply> DestroyAuthenticatorReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DestroyAuthenticatorReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDestroyAuthenticatorReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DestroyAuthenticatorReply> CreateDestroyAuthenticatorReply(flatbuffers::FlatBufferBuilder &_fbb, const DestroyAuthenticatorReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DestroyAuthenticatorReplyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _status = _o->status;
  return nfcdoorz::ipc::api::CreateDestroyAuthenticatorReply(
      _fbb,
      _status);
}

inline AuthenticatorExitEventT *AuthenticatorExitEvent::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AuthenticatorExitEventT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AuthenticatorExitEvent::UnPackTo(AuthenticatorExitEventT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = deviceID(); if (_e) _o->deviceID = _e->str(); };
}

inline flatbuffers::Offset<AuthenticatorExitEvent> AuthenticatorExitEvent::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticatorExitEventT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAuthenticatorExitEvent(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AuthenticatorExitEvent> CreateAuthenticatorExitEvent(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticatorExitEventT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AuthenticatorExitEventT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _deviceID = _o->deviceID.empty() ? 0 : _fbb.CreateString(_o->deviceID);
  return nfcdoorz::ipc::api::CreateAuthenticatorExitEvent(
      _fbb,
      _deviceID);
}

inline APICallT *APICall::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new APICallT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void APICall::UnPackTo(APICallT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = msg_type(); _o->msg.type = _e; };
  { auto _e = msg(); if (_e) _o->msg.value = APICallsUnion::UnPack(_e, msg_type(), _resolver); };
}

inline flatbuffers::Offset<APICall> APICall::Pack(flatbuffers::FlatBufferBuilder &_fbb, const APICallT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAPICall(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<APICall> CreateAPICall(flatbuffers::FlatBufferBuilder &_fbb, const APICallT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const APICallT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _msg_type = _o->msg.type;
  auto _msg = _o->msg.Pack(_fbb);
  return nfcdoorz::ipc::api::CreateAPICall(
      _fbb,
      _id,
      _msg_type,
      _msg);
}

inline APIReplyT *APIReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new APIReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void APIReply::UnPackTo(APIReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = msg_type(); _o->msg.type = _e; };
  { auto _e = msg(); if (_e) _o->msg.value = APIRepliesUnion::UnPack(_e, msg_type(), _resolver); };
  { auto _e = event_type(); _o->event.type = _e; };
  { auto _e = event(); if (_e) _o->event.value = APIEventsUnion::UnPack(_e, event_type(), _resolver); };
}

inline flatbuffers::Offset<APIReply> APIReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const APIReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAPIReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<APIReply> CreateAPIReply(flatbuffers::FlatBufferBuilder &_fbb, const APIReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const APIReplyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _msg_type = _o->msg.type;
  auto _msg = _o->msg.Pack(_fbb);
  auto _event_type = _o->event.type;
  auto _event = _o->event.Pack(_fbb);
  return nfcdoorz::ipc::api::CreateAPIReply(
      _fbb,
      _id,
      _msg_type,
      _msg,
      _event_type,
      _event);
}

inline ServerT *Server::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ServerT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Server::UnPackTo(ServerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = call(); if (_e) _o->call = std::unique_ptr<APICallT>(_e->UnPack(_resolver)); };
  { auto _e = reply(); if (_e) _o->reply = std::unique_ptr<APIReplyT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Server> Server::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateServer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Server> CreateServer(flatbuffers::FlatBufferBuilder &_fbb, const ServerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ServerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _call = _o->call ? CreateAPICall(_fbb, _o->call.get(), _rehasher) : 0;
  auto _reply = _o->reply ? CreateAPIReply(_fbb, _o->reply.get(), _rehasher) : 0;
  return nfcdoorz::ipc::api::CreateServer(
      _fbb,
      _call,
      _reply);
}

inline bool VerifyAPICalls(flatbuffers::Verifier &verifier, const void *obj, APICalls type) {
  switch (type) {
    case APICalls::NONE: {
      return true;
    }
    case APICalls::StatusCall: {
      auto ptr = reinterpret_cast<const StatusCall *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case APICalls::CreateAuthenticatorCall: {
      auto ptr = reinterpret_cast<const CreateAuthenticatorCall *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case APICalls::DestroyAuthenticatorCall: {
      auto ptr = reinterpret_cast<const DestroyAuthenticatorCall *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyAPICallsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAPICalls(
        verifier,  values->Get(i), types->GetEnum<APICalls>(i))) {
      return false;
    }
  }
  return true;
}

inline void *APICallsUnion::UnPack(const void *obj, APICalls type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case APICalls::StatusCall: {
      auto ptr = reinterpret_cast<const StatusCall *>(obj);
      return ptr->UnPack(resolver);
    }
    case APICalls::CreateAuthenticatorCall: {
      auto ptr = reinterpret_cast<const CreateAuthenticatorCall *>(obj);
      return ptr->UnPack(resolver);
    }
    case APICalls::DestroyAuthenticatorCall: {
      auto ptr = reinterpret_cast<const DestroyAuthenticatorCall *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> APICallsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case APICalls::StatusCall: {
      auto ptr = reinterpret_cast<const StatusCallT *>(value);
      return CreateStatusCall(_fbb, ptr, _rehasher).Union();
    }
    case APICalls::CreateAuthenticatorCall: {
      auto ptr = reinterpret_cast<const CreateAuthenticatorCallT *>(value);
      return CreateCreateAuthenticatorCall(_fbb, ptr, _rehasher).Union();
    }
    case APICalls::DestroyAuthenticatorCall: {
      auto ptr = reinterpret_cast<const DestroyAuthenticatorCallT *>(value);
      return CreateDestroyAuthenticatorCall(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline APICallsUnion::APICallsUnion(const APICallsUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case APICalls::StatusCall: {
      value = new StatusCallT(*reinterpret_cast<StatusCallT *>(u.value));
      break;
    }
    case APICalls::CreateAuthenticatorCall: {
      value = new CreateAuthenticatorCallT(*reinterpret_cast<CreateAuthenticatorCallT *>(u.value));
      break;
    }
    case APICalls::DestroyAuthenticatorCall: {
      value = new DestroyAuthenticatorCallT(*reinterpret_cast<DestroyAuthenticatorCallT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void APICallsUnion::Reset() {
  switch (type) {
    case APICalls::StatusCall: {
      auto ptr = reinterpret_cast<StatusCallT *>(value);
      delete ptr;
      break;
    }
    case APICalls::CreateAuthenticatorCall: {
      auto ptr = reinterpret_cast<CreateAuthenticatorCallT *>(value);
      delete ptr;
      break;
    }
    case APICalls::DestroyAuthenticatorCall: {
      auto ptr = reinterpret_cast<DestroyAuthenticatorCallT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = APICalls::NONE;
}

inline bool VerifyAPIReplies(flatbuffers::Verifier &verifier, const void *obj, APIReplies type) {
  switch (type) {
    case APIReplies::NONE: {
      return true;
    }
    case APIReplies::StatusReply: {
      auto ptr = reinterpret_cast<const StatusReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case APIReplies::CreateAuthenticatorReply: {
      auto ptr = reinterpret_cast<const CreateAuthenticatorReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case APIReplies::DestroyAuthenticatorReply: {
      auto ptr = reinterpret_cast<const DestroyAuthenticatorReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyAPIRepliesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAPIReplies(
        verifier,  values->Get(i), types->GetEnum<APIReplies>(i))) {
      return false;
    }
  }
  return true;
}

inline void *APIRepliesUnion::UnPack(const void *obj, APIReplies type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case APIReplies::StatusReply: {
      auto ptr = reinterpret_cast<const StatusReply *>(obj);
      return ptr->UnPack(resolver);
    }
    case APIReplies::CreateAuthenticatorReply: {
      auto ptr = reinterpret_cast<const CreateAuthenticatorReply *>(obj);
      return ptr->UnPack(resolver);
    }
    case APIReplies::DestroyAuthenticatorReply: {
      auto ptr = reinterpret_cast<const DestroyAuthenticatorReply *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> APIRepliesUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case APIReplies::StatusReply: {
      auto ptr = reinterpret_cast<const StatusReplyT *>(value);
      return CreateStatusReply(_fbb, ptr, _rehasher).Union();
    }
    case APIReplies::CreateAuthenticatorReply: {
      auto ptr = reinterpret_cast<const CreateAuthenticatorReplyT *>(value);
      return CreateCreateAuthenticatorReply(_fbb, ptr, _rehasher).Union();
    }
    case APIReplies::DestroyAuthenticatorReply: {
      auto ptr = reinterpret_cast<const DestroyAuthenticatorReplyT *>(value);
      return CreateDestroyAuthenticatorReply(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline APIRepliesUnion::APIRepliesUnion(const APIRepliesUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case APIReplies::StatusReply: {
      FLATBUFFERS_ASSERT(false);  // StatusReplyT not copyable.
      break;
    }
    case APIReplies::CreateAuthenticatorReply: {
      value = new CreateAuthenticatorReplyT(*reinterpret_cast<CreateAuthenticatorReplyT *>(u.value));
      break;
    }
    case APIReplies::DestroyAuthenticatorReply: {
      value = new DestroyAuthenticatorReplyT(*reinterpret_cast<DestroyAuthenticatorReplyT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void APIRepliesUnion::Reset() {
  switch (type) {
    case APIReplies::StatusReply: {
      auto ptr = reinterpret_cast<StatusReplyT *>(value);
      delete ptr;
      break;
    }
    case APIReplies::CreateAuthenticatorReply: {
      auto ptr = reinterpret_cast<CreateAuthenticatorReplyT *>(value);
      delete ptr;
      break;
    }
    case APIReplies::DestroyAuthenticatorReply: {
      auto ptr = reinterpret_cast<DestroyAuthenticatorReplyT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = APIReplies::NONE;
}

inline bool VerifyAPIEvents(flatbuffers::Verifier &verifier, const void *obj, APIEvents type) {
  switch (type) {
    case APIEvents::NONE: {
      return true;
    }
    case APIEvents::AuthenticatorExitEvent: {
      auto ptr = reinterpret_cast<const AuthenticatorExitEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyAPIEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAPIEvents(
        verifier,  values->Get(i), types->GetEnum<APIEvents>(i))) {
      return false;
    }
  }
  return true;
}

inline void *APIEventsUnion::UnPack(const void *obj, APIEvents type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case APIEvents::AuthenticatorExitEvent: {
      auto ptr = reinterpret_cast<const AuthenticatorExitEvent *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> APIEventsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case APIEvents::AuthenticatorExitEvent: {
      auto ptr = reinterpret_cast<const AuthenticatorExitEventT *>(value);
      return CreateAuthenticatorExitEvent(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline APIEventsUnion::APIEventsUnion(const APIEventsUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case APIEvents::AuthenticatorExitEvent: {
      value = new AuthenticatorExitEventT(*reinterpret_cast<AuthenticatorExitEventT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void APIEventsUnion::Reset() {
  switch (type) {
    case APIEvents::AuthenticatorExitEvent: {
      auto ptr = reinterpret_cast<AuthenticatorExitEventT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = APIEvents::NONE;
}

inline const flatbuffers::TypeTable *APICallsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    StatusCallTypeTable,
    CreateAuthenticatorCallTypeTable,
    DestroyAuthenticatorCallTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "StatusCall",
    "CreateAuthenticatorCall",
    "DestroyAuthenticatorCall"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *APIRepliesTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    StatusReplyTypeTable,
    CreateAuthenticatorReplyTypeTable,
    DestroyAuthenticatorReplyTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "StatusReply",
    "CreateAuthenticatorReply",
    "DestroyAuthenticatorReply"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *APIEventsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AuthenticatorExitEventTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "AuthenticatorExitEvent"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StatusCallTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ProcessTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 1, -1 }
  };
  static const char * const names[] = {
    "pid",
    "name",
    "args"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StatusReplyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ProcessTypeTable
  };
  static const char * const names[] = {
    "processes"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CreateAuthenticatorCallTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "ttyName",
    "deviceID"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CreateAuthenticatorReplyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "status"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DestroyAuthenticatorCallTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "deviceID"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DestroyAuthenticatorReplyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "status"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AuthenticatorExitEventTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "deviceID"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *APICallTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    APICallsTypeTable
  };
  static const char * const names[] = {
    "id",
    "msg_type",
    "msg"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *APIReplyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_UTYPE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    APIRepliesTypeTable,
    APIEventsTypeTable
  };
  static const char * const names[] = {
    "id",
    "msg_type",
    "msg",
    "event_type",
    "event"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ServerTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    APICallTypeTable,
    APIReplyTypeTable
  };
  static const char * const names[] = {
    "call",
    "reply"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

}  // namespace api
}  // namespace ipc
}  // namespace nfcdoorz

#endif  // FLATBUFFERS_GENERATED_IPCAPI_NFCDOORZ_IPC_API_H_
