// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_IPCAUTH_NFCDOORZ_IPC_AUTH_H_
#define FLATBUFFERS_GENERATED_IPCAUTH_NFCDOORZ_IPC_AUTH_H_

#include "flatbuffers/flatbuffers.h"

namespace nfcdoorz {
namespace ipc {
namespace auth {

struct Ping;
struct PingT;

struct AppID;
struct AppIDT;

struct Key;
struct KeyT;

struct TagResult;
struct TagResultT;

struct AuthApp;
struct AuthAppT;

struct GetUID;
struct GetUIDT;

struct TagPresent;
struct TagPresentT;

struct TagUIDResult;
struct TagUIDResultT;

struct Result;
struct ResultT;

struct RandomEvent;
struct RandomEventT;

struct AuthCall;
struct AuthCallT;

struct AuthReply;
struct AuthReplyT;

struct Server;
struct ServerT;

inline const flatbuffers::TypeTable *PingTypeTable();

inline const flatbuffers::TypeTable *AppIDTypeTable();

inline const flatbuffers::TypeTable *KeyTypeTable();

inline const flatbuffers::TypeTable *TagResultTypeTable();

inline const flatbuffers::TypeTable *AuthAppTypeTable();

inline const flatbuffers::TypeTable *GetUIDTypeTable();

inline const flatbuffers::TypeTable *TagPresentTypeTable();

inline const flatbuffers::TypeTable *TagUIDResultTypeTable();

inline const flatbuffers::TypeTable *ResultTypeTable();

inline const flatbuffers::TypeTable *RandomEventTypeTable();

inline const flatbuffers::TypeTable *AuthCallTypeTable();

inline const flatbuffers::TypeTable *AuthReplyTypeTable();

inline const flatbuffers::TypeTable *ServerTypeTable();

enum class ResultData : uint8_t {
  NONE = 0,
  TagUIDResult = 1,
  MIN = NONE,
  MAX = TagUIDResult
};

inline const ResultData (&EnumValuesResultData())[2] {
  static const ResultData values[] = {
    ResultData::NONE,
    ResultData::TagUIDResult
  };
  return values;
}

inline const char * const *EnumNamesResultData() {
  static const char * const names[] = {
    "NONE",
    "TagUIDResult",
    nullptr
  };
  return names;
}

inline const char *EnumNameResultData(ResultData e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesResultData()[index];
}

template<typename T> struct ResultDataTraits {
  static const ResultData enum_value = ResultData::NONE;
};

template<> struct ResultDataTraits<TagUIDResult> {
  static const ResultData enum_value = ResultData::TagUIDResult;
};

struct ResultDataUnion {
  ResultData type;
  void *value;

  ResultDataUnion() : type(ResultData::NONE), value(nullptr) {}
  ResultDataUnion(ResultDataUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ResultData::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ResultDataUnion(const ResultDataUnion &) FLATBUFFERS_NOEXCEPT;
  ResultDataUnion &operator=(const ResultDataUnion &u) FLATBUFFERS_NOEXCEPT
    { ResultDataUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ResultDataUnion &operator=(ResultDataUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ResultDataUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = ResultDataTraits<typename T::TableType>::enum_value;
    if (type != ResultData::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, ResultData type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  TagUIDResultT *AsTagUIDResult() {
    return type == ResultData::TagUIDResult ?
      reinterpret_cast<TagUIDResultT *>(value) : nullptr;
  }
  const TagUIDResultT *AsTagUIDResult() const {
    return type == ResultData::TagUIDResult ?
      reinterpret_cast<const TagUIDResultT *>(value) : nullptr;
  }
};

bool VerifyResultData(flatbuffers::Verifier &verifier, const void *obj, ResultData type);
bool VerifyResultDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class AuthCalls : uint8_t {
  NONE = 0,
  TagPresent = 1,
  Result = 2,
  MIN = NONE,
  MAX = Result
};

inline const AuthCalls (&EnumValuesAuthCalls())[3] {
  static const AuthCalls values[] = {
    AuthCalls::NONE,
    AuthCalls::TagPresent,
    AuthCalls::Result
  };
  return values;
}

inline const char * const *EnumNamesAuthCalls() {
  static const char * const names[] = {
    "NONE",
    "TagPresent",
    "Result",
    nullptr
  };
  return names;
}

inline const char *EnumNameAuthCalls(AuthCalls e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAuthCalls()[index];
}

template<typename T> struct AuthCallsTraits {
  static const AuthCalls enum_value = AuthCalls::NONE;
};

template<> struct AuthCallsTraits<TagPresent> {
  static const AuthCalls enum_value = AuthCalls::TagPresent;
};

template<> struct AuthCallsTraits<Result> {
  static const AuthCalls enum_value = AuthCalls::Result;
};

struct AuthCallsUnion {
  AuthCalls type;
  void *value;

  AuthCallsUnion() : type(AuthCalls::NONE), value(nullptr) {}
  AuthCallsUnion(AuthCallsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(AuthCalls::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  AuthCallsUnion(const AuthCallsUnion &) FLATBUFFERS_NOEXCEPT;
  AuthCallsUnion &operator=(const AuthCallsUnion &u) FLATBUFFERS_NOEXCEPT
    { AuthCallsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  AuthCallsUnion &operator=(AuthCallsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~AuthCallsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = AuthCallsTraits<typename T::TableType>::enum_value;
    if (type != AuthCalls::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, AuthCalls type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  TagPresentT *AsTagPresent() {
    return type == AuthCalls::TagPresent ?
      reinterpret_cast<TagPresentT *>(value) : nullptr;
  }
  const TagPresentT *AsTagPresent() const {
    return type == AuthCalls::TagPresent ?
      reinterpret_cast<const TagPresentT *>(value) : nullptr;
  }
  ResultT *AsResult() {
    return type == AuthCalls::Result ?
      reinterpret_cast<ResultT *>(value) : nullptr;
  }
  const ResultT *AsResult() const {
    return type == AuthCalls::Result ?
      reinterpret_cast<const ResultT *>(value) : nullptr;
  }
};

bool VerifyAuthCalls(flatbuffers::Verifier &verifier, const void *obj, AuthCalls type);
bool VerifyAuthCallsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class AuthReplies : uint8_t {
  NONE = 0,
  AuthApp = 1,
  GetUID = 2,
  MIN = NONE,
  MAX = GetUID
};

inline const AuthReplies (&EnumValuesAuthReplies())[3] {
  static const AuthReplies values[] = {
    AuthReplies::NONE,
    AuthReplies::AuthApp,
    AuthReplies::GetUID
  };
  return values;
}

inline const char * const *EnumNamesAuthReplies() {
  static const char * const names[] = {
    "NONE",
    "AuthApp",
    "GetUID",
    nullptr
  };
  return names;
}

inline const char *EnumNameAuthReplies(AuthReplies e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAuthReplies()[index];
}

template<typename T> struct AuthRepliesTraits {
  static const AuthReplies enum_value = AuthReplies::NONE;
};

template<> struct AuthRepliesTraits<AuthApp> {
  static const AuthReplies enum_value = AuthReplies::AuthApp;
};

template<> struct AuthRepliesTraits<GetUID> {
  static const AuthReplies enum_value = AuthReplies::GetUID;
};

struct AuthRepliesUnion {
  AuthReplies type;
  void *value;

  AuthRepliesUnion() : type(AuthReplies::NONE), value(nullptr) {}
  AuthRepliesUnion(AuthRepliesUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(AuthReplies::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  AuthRepliesUnion(const AuthRepliesUnion &) FLATBUFFERS_NOEXCEPT;
  AuthRepliesUnion &operator=(const AuthRepliesUnion &u) FLATBUFFERS_NOEXCEPT
    { AuthRepliesUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  AuthRepliesUnion &operator=(AuthRepliesUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~AuthRepliesUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = AuthRepliesTraits<typename T::TableType>::enum_value;
    if (type != AuthReplies::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, AuthReplies type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  AuthAppT *AsAuthApp() {
    return type == AuthReplies::AuthApp ?
      reinterpret_cast<AuthAppT *>(value) : nullptr;
  }
  const AuthAppT *AsAuthApp() const {
    return type == AuthReplies::AuthApp ?
      reinterpret_cast<const AuthAppT *>(value) : nullptr;
  }
  GetUIDT *AsGetUID() {
    return type == AuthReplies::GetUID ?
      reinterpret_cast<GetUIDT *>(value) : nullptr;
  }
  const GetUIDT *AsGetUID() const {
    return type == AuthReplies::GetUID ?
      reinterpret_cast<const GetUIDT *>(value) : nullptr;
  }
};

bool VerifyAuthReplies(flatbuffers::Verifier &verifier, const void *obj, AuthReplies type);
bool VerifyAuthRepliesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class AuthEvents : uint8_t {
  NONE = 0,
  RandomEvent = 1,
  MIN = NONE,
  MAX = RandomEvent
};

inline const AuthEvents (&EnumValuesAuthEvents())[2] {
  static const AuthEvents values[] = {
    AuthEvents::NONE,
    AuthEvents::RandomEvent
  };
  return values;
}

inline const char * const *EnumNamesAuthEvents() {
  static const char * const names[] = {
    "NONE",
    "RandomEvent",
    nullptr
  };
  return names;
}

inline const char *EnumNameAuthEvents(AuthEvents e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAuthEvents()[index];
}

template<typename T> struct AuthEventsTraits {
  static const AuthEvents enum_value = AuthEvents::NONE;
};

template<> struct AuthEventsTraits<RandomEvent> {
  static const AuthEvents enum_value = AuthEvents::RandomEvent;
};

struct AuthEventsUnion {
  AuthEvents type;
  void *value;

  AuthEventsUnion() : type(AuthEvents::NONE), value(nullptr) {}
  AuthEventsUnion(AuthEventsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(AuthEvents::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  AuthEventsUnion(const AuthEventsUnion &) FLATBUFFERS_NOEXCEPT;
  AuthEventsUnion &operator=(const AuthEventsUnion &u) FLATBUFFERS_NOEXCEPT
    { AuthEventsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  AuthEventsUnion &operator=(AuthEventsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~AuthEventsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = AuthEventsTraits<typename T::TableType>::enum_value;
    if (type != AuthEvents::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, AuthEvents type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  RandomEventT *AsRandomEvent() {
    return type == AuthEvents::RandomEvent ?
      reinterpret_cast<RandomEventT *>(value) : nullptr;
  }
  const RandomEventT *AsRandomEvent() const {
    return type == AuthEvents::RandomEvent ?
      reinterpret_cast<const RandomEventT *>(value) : nullptr;
  }
};

bool VerifyAuthEvents(flatbuffers::Verifier &verifier, const void *obj, AuthEvents type);
bool VerifyAuthEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct PingT : public flatbuffers::NativeTable {
  typedef Ping TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.PingT";
  }
  PingT() {
  }
};

struct Ping FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PingT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PingTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.Ping";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Ping> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PingBuilder &operator=(const PingBuilder &);
  flatbuffers::Offset<Ping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ping>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ping> CreatePing(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PingBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Ping> CreatePing(flatbuffers::FlatBufferBuilder &_fbb, const PingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AppIDT : public flatbuffers::NativeTable {
  typedef AppID TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.AppIDT";
  }
  uint8_t a;
  uint8_t b;
  uint8_t c;
  AppIDT()
      : a(0),
        b(0),
        c(0) {
  }
};

struct AppID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AppIDT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AppIDTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.AppID";
  }
  enum {
    VT_A = 4,
    VT_B = 6,
    VT_C = 8
  };
  uint8_t a() const {
    return GetField<uint8_t>(VT_A, 0);
  }
  uint8_t b() const {
    return GetField<uint8_t>(VT_B, 0);
  }
  uint8_t c() const {
    return GetField<uint8_t>(VT_C, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_A) &&
           VerifyField<uint8_t>(verifier, VT_B) &&
           VerifyField<uint8_t>(verifier, VT_C) &&
           verifier.EndTable();
  }
  AppIDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AppIDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AppID> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AppIDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AppIDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_a(uint8_t a) {
    fbb_.AddElement<uint8_t>(AppID::VT_A, a, 0);
  }
  void add_b(uint8_t b) {
    fbb_.AddElement<uint8_t>(AppID::VT_B, b, 0);
  }
  void add_c(uint8_t c) {
    fbb_.AddElement<uint8_t>(AppID::VT_C, c, 0);
  }
  explicit AppIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AppIDBuilder &operator=(const AppIDBuilder &);
  flatbuffers::Offset<AppID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AppID>(end);
    return o;
  }
};

inline flatbuffers::Offset<AppID> CreateAppID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t a = 0,
    uint8_t b = 0,
    uint8_t c = 0) {
  AppIDBuilder builder_(_fbb);
  builder_.add_c(c);
  builder_.add_b(b);
  builder_.add_a(a);
  return builder_.Finish();
}

flatbuffers::Offset<AppID> CreateAppID(flatbuffers::FlatBufferBuilder &_fbb, const AppIDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct KeyT : public flatbuffers::NativeTable {
  typedef Key TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.KeyT";
  }
  std::string type;
  std::vector<uint8_t> data;
  KeyT() {
  }
};

struct Key FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KeyT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return KeyTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.Key";
  }
  enum {
    VT_TYPE = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  KeyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(KeyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Key> Pack(flatbuffers::FlatBufferBuilder &_fbb, const KeyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct KeyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(Key::VT_TYPE, type);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Key::VT_DATA, data);
  }
  explicit KeyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KeyBuilder &operator=(const KeyBuilder &);
  flatbuffers::Offset<Key> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Key>(end);
    return o;
  }
};

inline flatbuffers::Offset<Key> CreateKey(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  KeyBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Key> CreateKeyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  return nfcdoorz::ipc::auth::CreateKey(
      _fbb,
      type ? _fbb.CreateString(type) : 0,
      data ? _fbb.CreateVector<uint8_t>(*data) : 0);
}

flatbuffers::Offset<Key> CreateKey(flatbuffers::FlatBufferBuilder &_fbb, const KeyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TagResultT : public flatbuffers::NativeTable {
  typedef TagResult TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.TagResultT";
  }
  std::vector<uint8_t> uid;
  TagResultT() {
  }
};

struct TagResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TagResultT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TagResultTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.TagResult";
  }
  enum {
    VT_UID = 4
  };
  const flatbuffers::Vector<uint8_t> *uid() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_UID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UID) &&
           verifier.VerifyVector(uid()) &&
           verifier.EndTable();
  }
  TagResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TagResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TagResult> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TagResultT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TagResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uid(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> uid) {
    fbb_.AddOffset(TagResult::VT_UID, uid);
  }
  explicit TagResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TagResultBuilder &operator=(const TagResultBuilder &);
  flatbuffers::Offset<TagResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TagResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<TagResult> CreateTagResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> uid = 0) {
  TagResultBuilder builder_(_fbb);
  builder_.add_uid(uid);
  return builder_.Finish();
}

inline flatbuffers::Offset<TagResult> CreateTagResultDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *uid = nullptr) {
  return nfcdoorz::ipc::auth::CreateTagResult(
      _fbb,
      uid ? _fbb.CreateVector<uint8_t>(*uid) : 0);
}

flatbuffers::Offset<TagResult> CreateTagResult(flatbuffers::FlatBufferBuilder &_fbb, const TagResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthAppT : public flatbuffers::NativeTable {
  typedef AuthApp TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.AuthAppT";
  }
  std::unique_ptr<AppIDT> aid;
  std::unique_ptr<KeyT> key;
  AuthAppT() {
  }
};

struct AuthApp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AuthAppT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AuthAppTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.AuthApp";
  }
  enum {
    VT_AID = 4,
    VT_KEY = 6
  };
  const AppID *aid() const {
    return GetPointer<const AppID *>(VT_AID);
  }
  const Key *key() const {
    return GetPointer<const Key *>(VT_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AID) &&
           verifier.VerifyTable(aid()) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyTable(key()) &&
           verifier.EndTable();
  }
  AuthAppT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AuthAppT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AuthApp> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthAppT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AuthAppBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_aid(flatbuffers::Offset<AppID> aid) {
    fbb_.AddOffset(AuthApp::VT_AID, aid);
  }
  void add_key(flatbuffers::Offset<Key> key) {
    fbb_.AddOffset(AuthApp::VT_KEY, key);
  }
  explicit AuthAppBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AuthAppBuilder &operator=(const AuthAppBuilder &);
  flatbuffers::Offset<AuthApp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AuthApp>(end);
    return o;
  }
};

inline flatbuffers::Offset<AuthApp> CreateAuthApp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<AppID> aid = 0,
    flatbuffers::Offset<Key> key = 0) {
  AuthAppBuilder builder_(_fbb);
  builder_.add_key(key);
  builder_.add_aid(aid);
  return builder_.Finish();
}

flatbuffers::Offset<AuthApp> CreateAuthApp(flatbuffers::FlatBufferBuilder &_fbb, const AuthAppT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetUIDT : public flatbuffers::NativeTable {
  typedef GetUID TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.GetUIDT";
  }
  GetUIDT() {
  }
};

struct GetUID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetUIDT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GetUIDTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.GetUID";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GetUIDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetUIDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GetUID> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GetUIDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetUIDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GetUIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetUIDBuilder &operator=(const GetUIDBuilder &);
  flatbuffers::Offset<GetUID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetUID>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetUID> CreateGetUID(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GetUIDBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GetUID> CreateGetUID(flatbuffers::FlatBufferBuilder &_fbb, const GetUIDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TagPresentT : public flatbuffers::NativeTable {
  typedef TagPresent TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.TagPresentT";
  }
  bool present;
  TagPresentT()
      : present(false) {
  }
};

struct TagPresent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TagPresentT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TagPresentTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.TagPresent";
  }
  enum {
    VT_PRESENT = 4
  };
  bool present() const {
    return GetField<uint8_t>(VT_PRESENT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PRESENT) &&
           verifier.EndTable();
  }
  TagPresentT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TagPresentT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TagPresent> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TagPresentT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TagPresentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_present(bool present) {
    fbb_.AddElement<uint8_t>(TagPresent::VT_PRESENT, static_cast<uint8_t>(present), 0);
  }
  explicit TagPresentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TagPresentBuilder &operator=(const TagPresentBuilder &);
  flatbuffers::Offset<TagPresent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TagPresent>(end);
    return o;
  }
};

inline flatbuffers::Offset<TagPresent> CreateTagPresent(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool present = false) {
  TagPresentBuilder builder_(_fbb);
  builder_.add_present(present);
  return builder_.Finish();
}

flatbuffers::Offset<TagPresent> CreateTagPresent(flatbuffers::FlatBufferBuilder &_fbb, const TagPresentT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TagUIDResultT : public flatbuffers::NativeTable {
  typedef TagUIDResult TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.TagUIDResultT";
  }
  std::vector<uint8_t> uid;
  TagUIDResultT() {
  }
};

struct TagUIDResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TagUIDResultT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TagUIDResultTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.TagUIDResult";
  }
  enum {
    VT_UID = 4
  };
  const flatbuffers::Vector<uint8_t> *uid() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_UID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UID) &&
           verifier.VerifyVector(uid()) &&
           verifier.EndTable();
  }
  TagUIDResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TagUIDResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TagUIDResult> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TagUIDResultT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TagUIDResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uid(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> uid) {
    fbb_.AddOffset(TagUIDResult::VT_UID, uid);
  }
  explicit TagUIDResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TagUIDResultBuilder &operator=(const TagUIDResultBuilder &);
  flatbuffers::Offset<TagUIDResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TagUIDResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<TagUIDResult> CreateTagUIDResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> uid = 0) {
  TagUIDResultBuilder builder_(_fbb);
  builder_.add_uid(uid);
  return builder_.Finish();
}

inline flatbuffers::Offset<TagUIDResult> CreateTagUIDResultDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *uid = nullptr) {
  return nfcdoorz::ipc::auth::CreateTagUIDResult(
      _fbb,
      uid ? _fbb.CreateVector<uint8_t>(*uid) : 0);
}

flatbuffers::Offset<TagUIDResult> CreateTagUIDResult(flatbuffers::FlatBufferBuilder &_fbb, const TagUIDResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResultT : public flatbuffers::NativeTable {
  typedef Result TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.ResultT";
  }
  bool ok;
  ResultDataUnion data;
  ResultT()
      : ok(false) {
  }
};

struct Result FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResultT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ResultTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.Result";
  }
  enum {
    VT_OK = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  bool ok() const {
    return GetField<uint8_t>(VT_OK, 0) != 0;
  }
  ResultData data_type() const {
    return static_cast<ResultData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const TagUIDResult *data_as_TagUIDResult() const {
    return data_type() == ResultData::TagUIDResult ? static_cast<const TagUIDResult *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OK) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyResultData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
  ResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Result> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResultT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const TagUIDResult *Result::data_as<TagUIDResult>() const {
  return data_as_TagUIDResult();
}

struct ResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ok(bool ok) {
    fbb_.AddElement<uint8_t>(Result::VT_OK, static_cast<uint8_t>(ok), 0);
  }
  void add_data_type(ResultData data_type) {
    fbb_.AddElement<uint8_t>(Result::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(Result::VT_DATA, data);
  }
  explicit ResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResultBuilder &operator=(const ResultBuilder &);
  flatbuffers::Offset<Result> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Result>(end);
    return o;
  }
};

inline flatbuffers::Offset<Result> CreateResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool ok = false,
    ResultData data_type = ResultData::NONE,
    flatbuffers::Offset<void> data = 0) {
  ResultBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  builder_.add_ok(ok);
  return builder_.Finish();
}

flatbuffers::Offset<Result> CreateResult(flatbuffers::FlatBufferBuilder &_fbb, const ResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RandomEventT : public flatbuffers::NativeTable {
  typedef RandomEvent TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.RandomEventT";
  }
  RandomEventT() {
  }
};

struct RandomEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RandomEventT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RandomEventTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.RandomEvent";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RandomEventT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RandomEventT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RandomEvent> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RandomEventT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RandomEventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RandomEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RandomEventBuilder &operator=(const RandomEventBuilder &);
  flatbuffers::Offset<RandomEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RandomEvent>(end);
    return o;
  }
};

inline flatbuffers::Offset<RandomEvent> CreateRandomEvent(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RandomEventBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<RandomEvent> CreateRandomEvent(flatbuffers::FlatBufferBuilder &_fbb, const RandomEventT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthCallT : public flatbuffers::NativeTable {
  typedef AuthCall TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.AuthCallT";
  }
  uint64_t id;
  AuthCallsUnion msg;
  AuthCallT()
      : id(0) {
  }
};

struct AuthCall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AuthCallT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AuthCallTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.AuthCall";
  }
  enum {
    VT_ID = 4,
    VT_MSG_TYPE = 6,
    VT_MSG = 8
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  AuthCalls msg_type() const {
    return static_cast<AuthCalls>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const TagPresent *msg_as_TagPresent() const {
    return msg_type() == AuthCalls::TagPresent ? static_cast<const TagPresent *>(msg()) : nullptr;
  }
  const Result *msg_as_Result() const {
    return msg_type() == AuthCalls::Result ? static_cast<const Result *>(msg()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyAuthCalls(verifier, msg(), msg_type()) &&
           verifier.EndTable();
  }
  AuthCallT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AuthCallT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AuthCall> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthCallT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const TagPresent *AuthCall::msg_as<TagPresent>() const {
  return msg_as_TagPresent();
}

template<> inline const Result *AuthCall::msg_as<Result>() const {
  return msg_as_Result();
}

struct AuthCallBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(AuthCall::VT_ID, id, 0);
  }
  void add_msg_type(AuthCalls msg_type) {
    fbb_.AddElement<uint8_t>(AuthCall::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(AuthCall::VT_MSG, msg);
  }
  explicit AuthCallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AuthCallBuilder &operator=(const AuthCallBuilder &);
  flatbuffers::Offset<AuthCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AuthCall>(end);
    return o;
  }
};

inline flatbuffers::Offset<AuthCall> CreateAuthCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    AuthCalls msg_type = AuthCalls::NONE,
    flatbuffers::Offset<void> msg = 0) {
  AuthCallBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

flatbuffers::Offset<AuthCall> CreateAuthCall(flatbuffers::FlatBufferBuilder &_fbb, const AuthCallT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthReplyT : public flatbuffers::NativeTable {
  typedef AuthReply TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.AuthReplyT";
  }
  uint64_t id;
  AuthRepliesUnion msg;
  AuthEventsUnion event;
  AuthReplyT()
      : id(0) {
  }
};

struct AuthReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AuthReplyT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AuthReplyTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.AuthReply";
  }
  enum {
    VT_ID = 4,
    VT_MSG_TYPE = 6,
    VT_MSG = 8,
    VT_EVENT_TYPE = 10,
    VT_EVENT = 12
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  AuthReplies msg_type() const {
    return static_cast<AuthReplies>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const AuthApp *msg_as_AuthApp() const {
    return msg_type() == AuthReplies::AuthApp ? static_cast<const AuthApp *>(msg()) : nullptr;
  }
  const GetUID *msg_as_GetUID() const {
    return msg_type() == AuthReplies::GetUID ? static_cast<const GetUID *>(msg()) : nullptr;
  }
  AuthEvents event_type() const {
    return static_cast<AuthEvents>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  template<typename T> const T *event_as() const;
  const RandomEvent *event_as_RandomEvent() const {
    return event_type() == AuthEvents::RandomEvent ? static_cast<const RandomEvent *>(event()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyAuthReplies(verifier, msg(), msg_type()) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE) &&
           VerifyOffset(verifier, VT_EVENT) &&
           VerifyAuthEvents(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
  AuthReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AuthReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AuthReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const AuthApp *AuthReply::msg_as<AuthApp>() const {
  return msg_as_AuthApp();
}

template<> inline const GetUID *AuthReply::msg_as<GetUID>() const {
  return msg_as_GetUID();
}

template<> inline const RandomEvent *AuthReply::event_as<RandomEvent>() const {
  return event_as_RandomEvent();
}

struct AuthReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(AuthReply::VT_ID, id, 0);
  }
  void add_msg_type(AuthReplies msg_type) {
    fbb_.AddElement<uint8_t>(AuthReply::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(AuthReply::VT_MSG, msg);
  }
  void add_event_type(AuthEvents event_type) {
    fbb_.AddElement<uint8_t>(AuthReply::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(flatbuffers::Offset<void> event) {
    fbb_.AddOffset(AuthReply::VT_EVENT, event);
  }
  explicit AuthReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AuthReplyBuilder &operator=(const AuthReplyBuilder &);
  flatbuffers::Offset<AuthReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AuthReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<AuthReply> CreateAuthReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    AuthReplies msg_type = AuthReplies::NONE,
    flatbuffers::Offset<void> msg = 0,
    AuthEvents event_type = AuthEvents::NONE,
    flatbuffers::Offset<void> event = 0) {
  AuthReplyBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_event(event);
  builder_.add_msg(msg);
  builder_.add_event_type(event_type);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

flatbuffers::Offset<AuthReply> CreateAuthReply(flatbuffers::FlatBufferBuilder &_fbb, const AuthReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ServerT : public flatbuffers::NativeTable {
  typedef Server TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.ServerT";
  }
  std::unique_ptr<AuthCallT> call;
  std::unique_ptr<AuthReplyT> reply;
  ServerT() {
  }
};

struct Server FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ServerTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.Server";
  }
  enum {
    VT_CALL = 4,
    VT_REPLY = 6
  };
  const AuthCall *call() const {
    return GetPointer<const AuthCall *>(VT_CALL);
  }
  const AuthReply *reply() const {
    return GetPointer<const AuthReply *>(VT_REPLY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CALL) &&
           verifier.VerifyTable(call()) &&
           VerifyOffset(verifier, VT_REPLY) &&
           verifier.VerifyTable(reply()) &&
           verifier.EndTable();
  }
  ServerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ServerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Server> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ServerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_call(flatbuffers::Offset<AuthCall> call) {
    fbb_.AddOffset(Server::VT_CALL, call);
  }
  void add_reply(flatbuffers::Offset<AuthReply> reply) {
    fbb_.AddOffset(Server::VT_REPLY, reply);
  }
  explicit ServerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerBuilder &operator=(const ServerBuilder &);
  flatbuffers::Offset<Server> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Server>(end);
    return o;
  }
};

inline flatbuffers::Offset<Server> CreateServer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<AuthCall> call = 0,
    flatbuffers::Offset<AuthReply> reply = 0) {
  ServerBuilder builder_(_fbb);
  builder_.add_reply(reply);
  builder_.add_call(call);
  return builder_.Finish();
}

flatbuffers::Offset<Server> CreateServer(flatbuffers::FlatBufferBuilder &_fbb, const ServerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline PingT *Ping::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PingT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Ping::UnPackTo(PingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Ping> Ping::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePing(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Ping> CreatePing(flatbuffers::FlatBufferBuilder &_fbb, const PingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return nfcdoorz::ipc::auth::CreatePing(
      _fbb);
}

inline AppIDT *AppID::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AppIDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AppID::UnPackTo(AppIDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = a(); _o->a = _e; };
  { auto _e = b(); _o->b = _e; };
  { auto _e = c(); _o->c = _e; };
}

inline flatbuffers::Offset<AppID> AppID::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AppIDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAppID(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AppID> CreateAppID(flatbuffers::FlatBufferBuilder &_fbb, const AppIDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AppIDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _a = _o->a;
  auto _b = _o->b;
  auto _c = _o->c;
  return nfcdoorz::ipc::auth::CreateAppID(
      _fbb,
      _a,
      _b,
      _c);
}

inline KeyT *Key::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new KeyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Key::UnPackTo(KeyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = _e->str(); };
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Key> Key::Pack(flatbuffers::FlatBufferBuilder &_fbb, const KeyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateKey(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Key> CreateKey(flatbuffers::FlatBufferBuilder &_fbb, const KeyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const KeyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type.empty() ? 0 : _fbb.CreateString(_o->type);
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return nfcdoorz::ipc::auth::CreateKey(
      _fbb,
      _type,
      _data);
}

inline TagResultT *TagResult::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TagResultT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TagResult::UnPackTo(TagResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uid(); if (_e) { _o->uid.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->uid[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<TagResult> TagResult::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TagResultT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTagResult(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TagResult> CreateTagResult(flatbuffers::FlatBufferBuilder &_fbb, const TagResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TagResultT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uid = _o->uid.size() ? _fbb.CreateVector(_o->uid) : 0;
  return nfcdoorz::ipc::auth::CreateTagResult(
      _fbb,
      _uid);
}

inline AuthAppT *AuthApp::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AuthAppT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AuthApp::UnPackTo(AuthAppT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = aid(); if (_e) _o->aid = std::unique_ptr<AppIDT>(_e->UnPack(_resolver)); };
  { auto _e = key(); if (_e) _o->key = std::unique_ptr<KeyT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<AuthApp> AuthApp::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthAppT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAuthApp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AuthApp> CreateAuthApp(flatbuffers::FlatBufferBuilder &_fbb, const AuthAppT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AuthAppT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _aid = _o->aid ? CreateAppID(_fbb, _o->aid.get(), _rehasher) : 0;
  auto _key = _o->key ? CreateKey(_fbb, _o->key.get(), _rehasher) : 0;
  return nfcdoorz::ipc::auth::CreateAuthApp(
      _fbb,
      _aid,
      _key);
}

inline GetUIDT *GetUID::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GetUIDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GetUID::UnPackTo(GetUIDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GetUID> GetUID::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GetUIDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetUID(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GetUID> CreateGetUID(flatbuffers::FlatBufferBuilder &_fbb, const GetUIDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GetUIDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return nfcdoorz::ipc::auth::CreateGetUID(
      _fbb);
}

inline TagPresentT *TagPresent::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TagPresentT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TagPresent::UnPackTo(TagPresentT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = present(); _o->present = _e; };
}

inline flatbuffers::Offset<TagPresent> TagPresent::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TagPresentT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTagPresent(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TagPresent> CreateTagPresent(flatbuffers::FlatBufferBuilder &_fbb, const TagPresentT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TagPresentT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _present = _o->present;
  return nfcdoorz::ipc::auth::CreateTagPresent(
      _fbb,
      _present);
}

inline TagUIDResultT *TagUIDResult::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TagUIDResultT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TagUIDResult::UnPackTo(TagUIDResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uid(); if (_e) { _o->uid.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->uid[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<TagUIDResult> TagUIDResult::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TagUIDResultT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTagUIDResult(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TagUIDResult> CreateTagUIDResult(flatbuffers::FlatBufferBuilder &_fbb, const TagUIDResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TagUIDResultT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uid = _o->uid.size() ? _fbb.CreateVector(_o->uid) : 0;
  return nfcdoorz::ipc::auth::CreateTagUIDResult(
      _fbb,
      _uid);
}

inline ResultT *Result::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ResultT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Result::UnPackTo(ResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ok(); _o->ok = _e; };
  { auto _e = data_type(); _o->data.type = _e; };
  { auto _e = data(); if (_e) _o->data.value = ResultDataUnion::UnPack(_e, data_type(), _resolver); };
}

inline flatbuffers::Offset<Result> Result::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResultT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResult(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Result> CreateResult(flatbuffers::FlatBufferBuilder &_fbb, const ResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResultT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ok = _o->ok;
  auto _data_type = _o->data.type;
  auto _data = _o->data.Pack(_fbb);
  return nfcdoorz::ipc::auth::CreateResult(
      _fbb,
      _ok,
      _data_type,
      _data);
}

inline RandomEventT *RandomEvent::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RandomEventT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RandomEvent::UnPackTo(RandomEventT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<RandomEvent> RandomEvent::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RandomEventT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRandomEvent(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RandomEvent> CreateRandomEvent(flatbuffers::FlatBufferBuilder &_fbb, const RandomEventT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RandomEventT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return nfcdoorz::ipc::auth::CreateRandomEvent(
      _fbb);
}

inline AuthCallT *AuthCall::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AuthCallT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AuthCall::UnPackTo(AuthCallT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = msg_type(); _o->msg.type = _e; };
  { auto _e = msg(); if (_e) _o->msg.value = AuthCallsUnion::UnPack(_e, msg_type(), _resolver); };
}

inline flatbuffers::Offset<AuthCall> AuthCall::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthCallT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAuthCall(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AuthCall> CreateAuthCall(flatbuffers::FlatBufferBuilder &_fbb, const AuthCallT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AuthCallT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _msg_type = _o->msg.type;
  auto _msg = _o->msg.Pack(_fbb);
  return nfcdoorz::ipc::auth::CreateAuthCall(
      _fbb,
      _id,
      _msg_type,
      _msg);
}

inline AuthReplyT *AuthReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AuthReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AuthReply::UnPackTo(AuthReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = msg_type(); _o->msg.type = _e; };
  { auto _e = msg(); if (_e) _o->msg.value = AuthRepliesUnion::UnPack(_e, msg_type(), _resolver); };
  { auto _e = event_type(); _o->event.type = _e; };
  { auto _e = event(); if (_e) _o->event.value = AuthEventsUnion::UnPack(_e, event_type(), _resolver); };
}

inline flatbuffers::Offset<AuthReply> AuthReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAuthReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AuthReply> CreateAuthReply(flatbuffers::FlatBufferBuilder &_fbb, const AuthReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AuthReplyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _msg_type = _o->msg.type;
  auto _msg = _o->msg.Pack(_fbb);
  auto _event_type = _o->event.type;
  auto _event = _o->event.Pack(_fbb);
  return nfcdoorz::ipc::auth::CreateAuthReply(
      _fbb,
      _id,
      _msg_type,
      _msg,
      _event_type,
      _event);
}

inline ServerT *Server::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ServerT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Server::UnPackTo(ServerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = call(); if (_e) _o->call = std::unique_ptr<AuthCallT>(_e->UnPack(_resolver)); };
  { auto _e = reply(); if (_e) _o->reply = std::unique_ptr<AuthReplyT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Server> Server::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateServer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Server> CreateServer(flatbuffers::FlatBufferBuilder &_fbb, const ServerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ServerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _call = _o->call ? CreateAuthCall(_fbb, _o->call.get(), _rehasher) : 0;
  auto _reply = _o->reply ? CreateAuthReply(_fbb, _o->reply.get(), _rehasher) : 0;
  return nfcdoorz::ipc::auth::CreateServer(
      _fbb,
      _call,
      _reply);
}

inline bool VerifyResultData(flatbuffers::Verifier &verifier, const void *obj, ResultData type) {
  switch (type) {
    case ResultData::NONE: {
      return true;
    }
    case ResultData::TagUIDResult: {
      auto ptr = reinterpret_cast<const TagUIDResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyResultDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResultData(
        verifier,  values->Get(i), types->GetEnum<ResultData>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ResultDataUnion::UnPack(const void *obj, ResultData type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case ResultData::TagUIDResult: {
      auto ptr = reinterpret_cast<const TagUIDResult *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ResultDataUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case ResultData::TagUIDResult: {
      auto ptr = reinterpret_cast<const TagUIDResultT *>(value);
      return CreateTagUIDResult(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ResultDataUnion::ResultDataUnion(const ResultDataUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case ResultData::TagUIDResult: {
      value = new TagUIDResultT(*reinterpret_cast<TagUIDResultT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ResultDataUnion::Reset() {
  switch (type) {
    case ResultData::TagUIDResult: {
      auto ptr = reinterpret_cast<TagUIDResultT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ResultData::NONE;
}

inline bool VerifyAuthCalls(flatbuffers::Verifier &verifier, const void *obj, AuthCalls type) {
  switch (type) {
    case AuthCalls::NONE: {
      return true;
    }
    case AuthCalls::TagPresent: {
      auto ptr = reinterpret_cast<const TagPresent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AuthCalls::Result: {
      auto ptr = reinterpret_cast<const Result *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyAuthCallsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAuthCalls(
        verifier,  values->Get(i), types->GetEnum<AuthCalls>(i))) {
      return false;
    }
  }
  return true;
}

inline void *AuthCallsUnion::UnPack(const void *obj, AuthCalls type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case AuthCalls::TagPresent: {
      auto ptr = reinterpret_cast<const TagPresent *>(obj);
      return ptr->UnPack(resolver);
    }
    case AuthCalls::Result: {
      auto ptr = reinterpret_cast<const Result *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> AuthCallsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case AuthCalls::TagPresent: {
      auto ptr = reinterpret_cast<const TagPresentT *>(value);
      return CreateTagPresent(_fbb, ptr, _rehasher).Union();
    }
    case AuthCalls::Result: {
      auto ptr = reinterpret_cast<const ResultT *>(value);
      return CreateResult(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline AuthCallsUnion::AuthCallsUnion(const AuthCallsUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case AuthCalls::TagPresent: {
      value = new TagPresentT(*reinterpret_cast<TagPresentT *>(u.value));
      break;
    }
    case AuthCalls::Result: {
      value = new ResultT(*reinterpret_cast<ResultT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void AuthCallsUnion::Reset() {
  switch (type) {
    case AuthCalls::TagPresent: {
      auto ptr = reinterpret_cast<TagPresentT *>(value);
      delete ptr;
      break;
    }
    case AuthCalls::Result: {
      auto ptr = reinterpret_cast<ResultT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = AuthCalls::NONE;
}

inline bool VerifyAuthReplies(flatbuffers::Verifier &verifier, const void *obj, AuthReplies type) {
  switch (type) {
    case AuthReplies::NONE: {
      return true;
    }
    case AuthReplies::AuthApp: {
      auto ptr = reinterpret_cast<const AuthApp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AuthReplies::GetUID: {
      auto ptr = reinterpret_cast<const GetUID *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyAuthRepliesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAuthReplies(
        verifier,  values->Get(i), types->GetEnum<AuthReplies>(i))) {
      return false;
    }
  }
  return true;
}

inline void *AuthRepliesUnion::UnPack(const void *obj, AuthReplies type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case AuthReplies::AuthApp: {
      auto ptr = reinterpret_cast<const AuthApp *>(obj);
      return ptr->UnPack(resolver);
    }
    case AuthReplies::GetUID: {
      auto ptr = reinterpret_cast<const GetUID *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> AuthRepliesUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case AuthReplies::AuthApp: {
      auto ptr = reinterpret_cast<const AuthAppT *>(value);
      return CreateAuthApp(_fbb, ptr, _rehasher).Union();
    }
    case AuthReplies::GetUID: {
      auto ptr = reinterpret_cast<const GetUIDT *>(value);
      return CreateGetUID(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline AuthRepliesUnion::AuthRepliesUnion(const AuthRepliesUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case AuthReplies::AuthApp: {
      FLATBUFFERS_ASSERT(false);  // AuthAppT not copyable.
      break;
    }
    case AuthReplies::GetUID: {
      value = new GetUIDT(*reinterpret_cast<GetUIDT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void AuthRepliesUnion::Reset() {
  switch (type) {
    case AuthReplies::AuthApp: {
      auto ptr = reinterpret_cast<AuthAppT *>(value);
      delete ptr;
      break;
    }
    case AuthReplies::GetUID: {
      auto ptr = reinterpret_cast<GetUIDT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = AuthReplies::NONE;
}

inline bool VerifyAuthEvents(flatbuffers::Verifier &verifier, const void *obj, AuthEvents type) {
  switch (type) {
    case AuthEvents::NONE: {
      return true;
    }
    case AuthEvents::RandomEvent: {
      auto ptr = reinterpret_cast<const RandomEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyAuthEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAuthEvents(
        verifier,  values->Get(i), types->GetEnum<AuthEvents>(i))) {
      return false;
    }
  }
  return true;
}

inline void *AuthEventsUnion::UnPack(const void *obj, AuthEvents type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case AuthEvents::RandomEvent: {
      auto ptr = reinterpret_cast<const RandomEvent *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> AuthEventsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case AuthEvents::RandomEvent: {
      auto ptr = reinterpret_cast<const RandomEventT *>(value);
      return CreateRandomEvent(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline AuthEventsUnion::AuthEventsUnion(const AuthEventsUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case AuthEvents::RandomEvent: {
      value = new RandomEventT(*reinterpret_cast<RandomEventT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void AuthEventsUnion::Reset() {
  switch (type) {
    case AuthEvents::RandomEvent: {
      auto ptr = reinterpret_cast<RandomEventT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = AuthEvents::NONE;
}

inline const flatbuffers::TypeTable *ResultDataTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TagUIDResultTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "TagUIDResult"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AuthCallsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TagPresentTypeTable,
    ResultTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "TagPresent",
    "Result"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AuthRepliesTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AuthAppTypeTable,
    GetUIDTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "AuthApp",
    "GetUID"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AuthEventsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    RandomEventTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "RandomEvent"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PingTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AppIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "a",
    "b",
    "c"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *KeyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const char * const names[] = {
    "type",
    "data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TagResultTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const char * const names[] = {
    "uid"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AuthAppTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AppIDTypeTable,
    KeyTypeTable
  };
  static const char * const names[] = {
    "aid",
    "key"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GetUIDTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TagPresentTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "present"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TagUIDResultTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const char * const names[] = {
    "uid"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResultTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ResultDataTypeTable
  };
  static const char * const names[] = {
    "ok",
    "data_type",
    "data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RandomEventTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AuthCallTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AuthCallsTypeTable
  };
  static const char * const names[] = {
    "id",
    "msg_type",
    "msg"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AuthReplyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_UTYPE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AuthRepliesTypeTable,
    AuthEventsTypeTable
  };
  static const char * const names[] = {
    "id",
    "msg_type",
    "msg",
    "event_type",
    "event"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ServerTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AuthCallTypeTable,
    AuthReplyTypeTable
  };
  static const char * const names[] = {
    "call",
    "reply"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

}  // namespace auth
}  // namespace ipc
}  // namespace nfcdoorz

#endif  // FLATBUFFERS_GENERATED_IPCAUTH_NFCDOORZ_IPC_AUTH_H_
