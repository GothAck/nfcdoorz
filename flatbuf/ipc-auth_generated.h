// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_IPCAUTH_NFCDOORZ_IPC_AUTH_H_
#define FLATBUFFERS_GENERATED_IPCAUTH_NFCDOORZ_IPC_AUTH_H_

#include "flatbuffers/flatbuffers.h"

#include "ipc-common_generated.h"

namespace nfcdoorz {
namespace ipc {
namespace auth {

struct Ping;
struct PingT;

struct AppID;
struct AppIDT;

struct Key;
struct KeyT;

struct AuthApp;
struct AuthAppT;

struct GetUID;
struct GetUIDT;

struct TagPresent;
struct TagPresentT;

struct TagUIDResult;
struct TagUIDResultT;

struct Result;
struct ResultT;

struct TagThing;
struct TagThingT;

struct TagCall;
struct TagCallT;

struct TagReply;
struct TagReplyT;

struct RandomEvent;
struct RandomEventT;

struct Call;
struct CallT;

struct Reply;
struct ReplyT;

struct Server;
struct ServerT;

inline const flatbuffers::TypeTable *PingTypeTable();

inline const flatbuffers::TypeTable *AppIDTypeTable();

inline const flatbuffers::TypeTable *KeyTypeTable();

inline const flatbuffers::TypeTable *AuthAppTypeTable();

inline const flatbuffers::TypeTable *GetUIDTypeTable();

inline const flatbuffers::TypeTable *TagPresentTypeTable();

inline const flatbuffers::TypeTable *TagUIDResultTypeTable();

inline const flatbuffers::TypeTable *ResultTypeTable();

inline const flatbuffers::TypeTable *TagThingTypeTable();

inline const flatbuffers::TypeTable *TagCallTypeTable();

inline const flatbuffers::TypeTable *TagReplyTypeTable();

inline const flatbuffers::TypeTable *RandomEventTypeTable();

inline const flatbuffers::TypeTable *CallTypeTable();

inline const flatbuffers::TypeTable *ReplyTypeTable();

inline const flatbuffers::TypeTable *ServerTypeTable();

enum class ResultData : uint8_t {
  NONE = 0,
  TagUIDResult = 1,
  MIN = NONE,
  MAX = TagUIDResult
};

inline const ResultData (&EnumValuesResultData())[2] {
  static const ResultData values[] = {
    ResultData::NONE,
    ResultData::TagUIDResult
  };
  return values;
}

inline const char * const *EnumNamesResultData() {
  static const char * const names[] = {
    "NONE",
    "TagUIDResult",
    nullptr
  };
  return names;
}

inline const char *EnumNameResultData(ResultData e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesResultData()[index];
}

template<typename T> struct ResultDataTraits {
  static const ResultData enum_value = ResultData::NONE;
};

template<> struct ResultDataTraits<TagUIDResult> {
  static const ResultData enum_value = ResultData::TagUIDResult;
};

struct ResultDataUnion {
  ResultData type;
  void *value;

  ResultDataUnion() : type(ResultData::NONE), value(nullptr) {}
  ResultDataUnion(ResultDataUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ResultData::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ResultDataUnion(const ResultDataUnion &) FLATBUFFERS_NOEXCEPT;
  ResultDataUnion &operator=(const ResultDataUnion &u) FLATBUFFERS_NOEXCEPT
    { ResultDataUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ResultDataUnion &operator=(ResultDataUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ResultDataUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = ResultDataTraits<typename T::TableType>::enum_value;
    if (type != ResultData::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, ResultData type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  TagUIDResultT *AsTagUIDResult() {
    return type == ResultData::TagUIDResult ?
      reinterpret_cast<TagUIDResultT *>(value) : nullptr;
  }
  const TagUIDResultT *AsTagUIDResult() const {
    return type == ResultData::TagUIDResult ?
      reinterpret_cast<const TagUIDResultT *>(value) : nullptr;
  }
};

bool VerifyResultData(flatbuffers::Verifier &verifier, const void *obj, ResultData type);
bool VerifyResultDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class Calls : uint8_t {
  NONE = 0,
  nfcdoorz_ipc_common_ConfigCall = 1,
  TagCall = 2,
  MIN = NONE,
  MAX = TagCall
};

inline const Calls (&EnumValuesCalls())[3] {
  static const Calls values[] = {
    Calls::NONE,
    Calls::nfcdoorz_ipc_common_ConfigCall,
    Calls::TagCall
  };
  return values;
}

inline const char * const *EnumNamesCalls() {
  static const char * const names[] = {
    "NONE",
    "nfcdoorz_ipc_common_ConfigCall",
    "TagCall",
    nullptr
  };
  return names;
}

inline const char *EnumNameCalls(Calls e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCalls()[index];
}

template<typename T> struct CallsTraits {
  static const Calls enum_value = Calls::NONE;
};

template<> struct CallsTraits<nfcdoorz::ipc::common::ConfigCall> {
  static const Calls enum_value = Calls::nfcdoorz_ipc_common_ConfigCall;
};

template<> struct CallsTraits<TagCall> {
  static const Calls enum_value = Calls::TagCall;
};

struct CallsUnion {
  Calls type;
  void *value;

  CallsUnion() : type(Calls::NONE), value(nullptr) {}
  CallsUnion(CallsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Calls::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  CallsUnion(const CallsUnion &) FLATBUFFERS_NOEXCEPT;
  CallsUnion &operator=(const CallsUnion &u) FLATBUFFERS_NOEXCEPT
    { CallsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  CallsUnion &operator=(CallsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~CallsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = CallsTraits<typename T::TableType>::enum_value;
    if (type != Calls::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Calls type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  nfcdoorz::ipc::common::ConfigCallT *Asnfcdoorz_ipc_common_ConfigCall() {
    return type == Calls::nfcdoorz_ipc_common_ConfigCall ?
      reinterpret_cast<nfcdoorz::ipc::common::ConfigCallT *>(value) : nullptr;
  }
  const nfcdoorz::ipc::common::ConfigCallT *Asnfcdoorz_ipc_common_ConfigCall() const {
    return type == Calls::nfcdoorz_ipc_common_ConfigCall ?
      reinterpret_cast<const nfcdoorz::ipc::common::ConfigCallT *>(value) : nullptr;
  }
  TagCallT *AsTagCall() {
    return type == Calls::TagCall ?
      reinterpret_cast<TagCallT *>(value) : nullptr;
  }
  const TagCallT *AsTagCall() const {
    return type == Calls::TagCall ?
      reinterpret_cast<const TagCallT *>(value) : nullptr;
  }
};

bool VerifyCalls(flatbuffers::Verifier &verifier, const void *obj, Calls type);
bool VerifyCallsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class Replies : uint8_t {
  NONE = 0,
  nfcdoorz_ipc_common_ConfigReply = 1,
  TagReply = 2,
  MIN = NONE,
  MAX = TagReply
};

inline const Replies (&EnumValuesReplies())[3] {
  static const Replies values[] = {
    Replies::NONE,
    Replies::nfcdoorz_ipc_common_ConfigReply,
    Replies::TagReply
  };
  return values;
}

inline const char * const *EnumNamesReplies() {
  static const char * const names[] = {
    "NONE",
    "nfcdoorz_ipc_common_ConfigReply",
    "TagReply",
    nullptr
  };
  return names;
}

inline const char *EnumNameReplies(Replies e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesReplies()[index];
}

template<typename T> struct RepliesTraits {
  static const Replies enum_value = Replies::NONE;
};

template<> struct RepliesTraits<nfcdoorz::ipc::common::ConfigReply> {
  static const Replies enum_value = Replies::nfcdoorz_ipc_common_ConfigReply;
};

template<> struct RepliesTraits<TagReply> {
  static const Replies enum_value = Replies::TagReply;
};

struct RepliesUnion {
  Replies type;
  void *value;

  RepliesUnion() : type(Replies::NONE), value(nullptr) {}
  RepliesUnion(RepliesUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Replies::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  RepliesUnion(const RepliesUnion &) FLATBUFFERS_NOEXCEPT;
  RepliesUnion &operator=(const RepliesUnion &u) FLATBUFFERS_NOEXCEPT
    { RepliesUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  RepliesUnion &operator=(RepliesUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~RepliesUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = RepliesTraits<typename T::TableType>::enum_value;
    if (type != Replies::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Replies type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  nfcdoorz::ipc::common::ConfigReplyT *Asnfcdoorz_ipc_common_ConfigReply() {
    return type == Replies::nfcdoorz_ipc_common_ConfigReply ?
      reinterpret_cast<nfcdoorz::ipc::common::ConfigReplyT *>(value) : nullptr;
  }
  const nfcdoorz::ipc::common::ConfigReplyT *Asnfcdoorz_ipc_common_ConfigReply() const {
    return type == Replies::nfcdoorz_ipc_common_ConfigReply ?
      reinterpret_cast<const nfcdoorz::ipc::common::ConfigReplyT *>(value) : nullptr;
  }
  TagReplyT *AsTagReply() {
    return type == Replies::TagReply ?
      reinterpret_cast<TagReplyT *>(value) : nullptr;
  }
  const TagReplyT *AsTagReply() const {
    return type == Replies::TagReply ?
      reinterpret_cast<const TagReplyT *>(value) : nullptr;
  }
};

bool VerifyReplies(flatbuffers::Verifier &verifier, const void *obj, Replies type);
bool VerifyRepliesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class Events : uint8_t {
  NONE = 0,
  RandomEvent = 1,
  MIN = NONE,
  MAX = RandomEvent
};

inline const Events (&EnumValuesEvents())[2] {
  static const Events values[] = {
    Events::NONE,
    Events::RandomEvent
  };
  return values;
}

inline const char * const *EnumNamesEvents() {
  static const char * const names[] = {
    "NONE",
    "RandomEvent",
    nullptr
  };
  return names;
}

inline const char *EnumNameEvents(Events e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEvents()[index];
}

template<typename T> struct EventsTraits {
  static const Events enum_value = Events::NONE;
};

template<> struct EventsTraits<RandomEvent> {
  static const Events enum_value = Events::RandomEvent;
};

struct EventsUnion {
  Events type;
  void *value;

  EventsUnion() : type(Events::NONE), value(nullptr) {}
  EventsUnion(EventsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Events::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  EventsUnion(const EventsUnion &) FLATBUFFERS_NOEXCEPT;
  EventsUnion &operator=(const EventsUnion &u) FLATBUFFERS_NOEXCEPT
    { EventsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  EventsUnion &operator=(EventsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~EventsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = EventsTraits<typename T::TableType>::enum_value;
    if (type != Events::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Events type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  RandomEventT *AsRandomEvent() {
    return type == Events::RandomEvent ?
      reinterpret_cast<RandomEventT *>(value) : nullptr;
  }
  const RandomEventT *AsRandomEvent() const {
    return type == Events::RandomEvent ?
      reinterpret_cast<const RandomEventT *>(value) : nullptr;
  }
};

bool VerifyEvents(flatbuffers::Verifier &verifier, const void *obj, Events type);
bool VerifyEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct PingT : public flatbuffers::NativeTable {
  typedef Ping TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.PingT";
  }
  PingT() {
  }
};

struct Ping FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PingT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PingTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.Ping";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Ping> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PingBuilder &operator=(const PingBuilder &);
  flatbuffers::Offset<Ping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ping>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ping> CreatePing(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PingBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Ping> CreatePing(flatbuffers::FlatBufferBuilder &_fbb, const PingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AppIDT : public flatbuffers::NativeTable {
  typedef AppID TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.AppIDT";
  }
  uint8_t a;
  uint8_t b;
  uint8_t c;
  AppIDT()
      : a(0),
        b(0),
        c(0) {
  }
};

struct AppID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AppIDT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AppIDTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.AppID";
  }
  enum {
    VT_A = 4,
    VT_B = 6,
    VT_C = 8
  };
  uint8_t a() const {
    return GetField<uint8_t>(VT_A, 0);
  }
  uint8_t b() const {
    return GetField<uint8_t>(VT_B, 0);
  }
  uint8_t c() const {
    return GetField<uint8_t>(VT_C, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_A) &&
           VerifyField<uint8_t>(verifier, VT_B) &&
           VerifyField<uint8_t>(verifier, VT_C) &&
           verifier.EndTable();
  }
  AppIDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AppIDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AppID> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AppIDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AppIDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_a(uint8_t a) {
    fbb_.AddElement<uint8_t>(AppID::VT_A, a, 0);
  }
  void add_b(uint8_t b) {
    fbb_.AddElement<uint8_t>(AppID::VT_B, b, 0);
  }
  void add_c(uint8_t c) {
    fbb_.AddElement<uint8_t>(AppID::VT_C, c, 0);
  }
  explicit AppIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AppIDBuilder &operator=(const AppIDBuilder &);
  flatbuffers::Offset<AppID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AppID>(end);
    return o;
  }
};

inline flatbuffers::Offset<AppID> CreateAppID(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t a = 0,
    uint8_t b = 0,
    uint8_t c = 0) {
  AppIDBuilder builder_(_fbb);
  builder_.add_c(c);
  builder_.add_b(b);
  builder_.add_a(a);
  return builder_.Finish();
}

flatbuffers::Offset<AppID> CreateAppID(flatbuffers::FlatBufferBuilder &_fbb, const AppIDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct KeyT : public flatbuffers::NativeTable {
  typedef Key TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.KeyT";
  }
  std::string type;
  std::vector<uint8_t> data;
  KeyT() {
  }
};

struct Key FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KeyT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return KeyTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.Key";
  }
  enum {
    VT_TYPE = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  KeyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(KeyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Key> Pack(flatbuffers::FlatBufferBuilder &_fbb, const KeyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct KeyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(Key::VT_TYPE, type);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Key::VT_DATA, data);
  }
  explicit KeyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KeyBuilder &operator=(const KeyBuilder &);
  flatbuffers::Offset<Key> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Key>(end);
    return o;
  }
};

inline flatbuffers::Offset<Key> CreateKey(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  KeyBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Key> CreateKeyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  return nfcdoorz::ipc::auth::CreateKey(
      _fbb,
      type ? _fbb.CreateString(type) : 0,
      data ? _fbb.CreateVector<uint8_t>(*data) : 0);
}

flatbuffers::Offset<Key> CreateKey(flatbuffers::FlatBufferBuilder &_fbb, const KeyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthAppT : public flatbuffers::NativeTable {
  typedef AuthApp TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.AuthAppT";
  }
  std::unique_ptr<AppIDT> aid;
  std::unique_ptr<KeyT> key;
  AuthAppT() {
  }
};

struct AuthApp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AuthAppT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AuthAppTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.AuthApp";
  }
  enum {
    VT_AID = 4,
    VT_KEY = 6
  };
  const AppID *aid() const {
    return GetPointer<const AppID *>(VT_AID);
  }
  const Key *key() const {
    return GetPointer<const Key *>(VT_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AID) &&
           verifier.VerifyTable(aid()) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyTable(key()) &&
           verifier.EndTable();
  }
  AuthAppT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AuthAppT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AuthApp> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthAppT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AuthAppBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_aid(flatbuffers::Offset<AppID> aid) {
    fbb_.AddOffset(AuthApp::VT_AID, aid);
  }
  void add_key(flatbuffers::Offset<Key> key) {
    fbb_.AddOffset(AuthApp::VT_KEY, key);
  }
  explicit AuthAppBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AuthAppBuilder &operator=(const AuthAppBuilder &);
  flatbuffers::Offset<AuthApp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AuthApp>(end);
    return o;
  }
};

inline flatbuffers::Offset<AuthApp> CreateAuthApp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<AppID> aid = 0,
    flatbuffers::Offset<Key> key = 0) {
  AuthAppBuilder builder_(_fbb);
  builder_.add_key(key);
  builder_.add_aid(aid);
  return builder_.Finish();
}

flatbuffers::Offset<AuthApp> CreateAuthApp(flatbuffers::FlatBufferBuilder &_fbb, const AuthAppT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetUIDT : public flatbuffers::NativeTable {
  typedef GetUID TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.GetUIDT";
  }
  GetUIDT() {
  }
};

struct GetUID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetUIDT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GetUIDTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.GetUID";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GetUIDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetUIDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GetUID> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GetUIDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetUIDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GetUIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetUIDBuilder &operator=(const GetUIDBuilder &);
  flatbuffers::Offset<GetUID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetUID>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetUID> CreateGetUID(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GetUIDBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GetUID> CreateGetUID(flatbuffers::FlatBufferBuilder &_fbb, const GetUIDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TagPresentT : public flatbuffers::NativeTable {
  typedef TagPresent TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.TagPresentT";
  }
  bool present;
  TagPresentT()
      : present(false) {
  }
};

struct TagPresent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TagPresentT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TagPresentTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.TagPresent";
  }
  enum {
    VT_PRESENT = 4
  };
  bool present() const {
    return GetField<uint8_t>(VT_PRESENT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PRESENT) &&
           verifier.EndTable();
  }
  TagPresentT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TagPresentT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TagPresent> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TagPresentT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TagPresentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_present(bool present) {
    fbb_.AddElement<uint8_t>(TagPresent::VT_PRESENT, static_cast<uint8_t>(present), 0);
  }
  explicit TagPresentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TagPresentBuilder &operator=(const TagPresentBuilder &);
  flatbuffers::Offset<TagPresent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TagPresent>(end);
    return o;
  }
};

inline flatbuffers::Offset<TagPresent> CreateTagPresent(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool present = false) {
  TagPresentBuilder builder_(_fbb);
  builder_.add_present(present);
  return builder_.Finish();
}

flatbuffers::Offset<TagPresent> CreateTagPresent(flatbuffers::FlatBufferBuilder &_fbb, const TagPresentT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TagUIDResultT : public flatbuffers::NativeTable {
  typedef TagUIDResult TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.TagUIDResultT";
  }
  std::vector<uint8_t> uid;
  TagUIDResultT() {
  }
};

struct TagUIDResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TagUIDResultT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TagUIDResultTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.TagUIDResult";
  }
  enum {
    VT_UID = 4
  };
  const flatbuffers::Vector<uint8_t> *uid() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_UID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UID) &&
           verifier.VerifyVector(uid()) &&
           verifier.EndTable();
  }
  TagUIDResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TagUIDResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TagUIDResult> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TagUIDResultT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TagUIDResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uid(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> uid) {
    fbb_.AddOffset(TagUIDResult::VT_UID, uid);
  }
  explicit TagUIDResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TagUIDResultBuilder &operator=(const TagUIDResultBuilder &);
  flatbuffers::Offset<TagUIDResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TagUIDResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<TagUIDResult> CreateTagUIDResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> uid = 0) {
  TagUIDResultBuilder builder_(_fbb);
  builder_.add_uid(uid);
  return builder_.Finish();
}

inline flatbuffers::Offset<TagUIDResult> CreateTagUIDResultDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *uid = nullptr) {
  return nfcdoorz::ipc::auth::CreateTagUIDResult(
      _fbb,
      uid ? _fbb.CreateVector<uint8_t>(*uid) : 0);
}

flatbuffers::Offset<TagUIDResult> CreateTagUIDResult(flatbuffers::FlatBufferBuilder &_fbb, const TagUIDResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResultT : public flatbuffers::NativeTable {
  typedef Result TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.ResultT";
  }
  bool ok;
  ResultDataUnion data;
  ResultT()
      : ok(false) {
  }
};

struct Result FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResultT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ResultTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.Result";
  }
  enum {
    VT_OK = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  bool ok() const {
    return GetField<uint8_t>(VT_OK, 0) != 0;
  }
  ResultData data_type() const {
    return static_cast<ResultData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const TagUIDResult *data_as_TagUIDResult() const {
    return data_type() == ResultData::TagUIDResult ? static_cast<const TagUIDResult *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OK) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyResultData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
  ResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Result> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResultT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const TagUIDResult *Result::data_as<TagUIDResult>() const {
  return data_as_TagUIDResult();
}

struct ResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ok(bool ok) {
    fbb_.AddElement<uint8_t>(Result::VT_OK, static_cast<uint8_t>(ok), 0);
  }
  void add_data_type(ResultData data_type) {
    fbb_.AddElement<uint8_t>(Result::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(Result::VT_DATA, data);
  }
  explicit ResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResultBuilder &operator=(const ResultBuilder &);
  flatbuffers::Offset<Result> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Result>(end);
    return o;
  }
};

inline flatbuffers::Offset<Result> CreateResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool ok = false,
    ResultData data_type = ResultData::NONE,
    flatbuffers::Offset<void> data = 0) {
  ResultBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  builder_.add_ok(ok);
  return builder_.Finish();
}

flatbuffers::Offset<Result> CreateResult(flatbuffers::FlatBufferBuilder &_fbb, const ResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TagThingT : public flatbuffers::NativeTable {
  typedef TagThing TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.TagThingT";
  }
  TagThingT() {
  }
};

struct TagThing FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TagThingT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TagThingTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.TagThing";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TagThingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TagThingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TagThing> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TagThingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TagThingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TagThingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TagThingBuilder &operator=(const TagThingBuilder &);
  flatbuffers::Offset<TagThing> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TagThing>(end);
    return o;
  }
};

inline flatbuffers::Offset<TagThing> CreateTagThing(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TagThingBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TagThing> CreateTagThing(flatbuffers::FlatBufferBuilder &_fbb, const TagThingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TagCallT : public flatbuffers::NativeTable {
  typedef TagCall TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.TagCallT";
  }
  std::vector<uint8_t> uid;
  TagCallT() {
  }
};

struct TagCall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TagCallT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TagCallTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.TagCall";
  }
  enum {
    VT_UID = 4
  };
  const flatbuffers::Vector<uint8_t> *uid() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_UID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UID) &&
           verifier.VerifyVector(uid()) &&
           verifier.EndTable();
  }
  TagCallT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TagCallT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TagCall> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TagCallT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TagCallBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uid(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> uid) {
    fbb_.AddOffset(TagCall::VT_UID, uid);
  }
  explicit TagCallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TagCallBuilder &operator=(const TagCallBuilder &);
  flatbuffers::Offset<TagCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TagCall>(end);
    return o;
  }
};

inline flatbuffers::Offset<TagCall> CreateTagCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> uid = 0) {
  TagCallBuilder builder_(_fbb);
  builder_.add_uid(uid);
  return builder_.Finish();
}

inline flatbuffers::Offset<TagCall> CreateTagCallDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *uid = nullptr) {
  return nfcdoorz::ipc::auth::CreateTagCall(
      _fbb,
      uid ? _fbb.CreateVector<uint8_t>(*uid) : 0);
}

flatbuffers::Offset<TagCall> CreateTagCall(flatbuffers::FlatBufferBuilder &_fbb, const TagCallT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TagReplyT : public flatbuffers::NativeTable {
  typedef TagReply TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.TagReplyT";
  }
  TagReplyT() {
  }
};

struct TagReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TagReplyT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TagReplyTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.TagReply";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TagReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TagReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TagReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TagReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TagReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TagReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TagReplyBuilder &operator=(const TagReplyBuilder &);
  flatbuffers::Offset<TagReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TagReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<TagReply> CreateTagReply(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TagReplyBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TagReply> CreateTagReply(flatbuffers::FlatBufferBuilder &_fbb, const TagReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RandomEventT : public flatbuffers::NativeTable {
  typedef RandomEvent TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.RandomEventT";
  }
  RandomEventT() {
  }
};

struct RandomEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RandomEventT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RandomEventTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.RandomEvent";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RandomEventT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RandomEventT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RandomEvent> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RandomEventT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RandomEventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RandomEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RandomEventBuilder &operator=(const RandomEventBuilder &);
  flatbuffers::Offset<RandomEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RandomEvent>(end);
    return o;
  }
};

inline flatbuffers::Offset<RandomEvent> CreateRandomEvent(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RandomEventBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<RandomEvent> CreateRandomEvent(flatbuffers::FlatBufferBuilder &_fbb, const RandomEventT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CallT : public flatbuffers::NativeTable {
  typedef Call TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.CallT";
  }
  uint64_t id;
  CallsUnion msg;
  CallT()
      : id(0) {
  }
};

struct Call FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CallT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CallTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.Call";
  }
  enum {
    VT_ID = 4,
    VT_MSG_TYPE = 6,
    VT_MSG = 8
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  Calls msg_type() const {
    return static_cast<Calls>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const nfcdoorz::ipc::common::ConfigCall *msg_as_nfcdoorz_ipc_common_ConfigCall() const {
    return msg_type() == Calls::nfcdoorz_ipc_common_ConfigCall ? static_cast<const nfcdoorz::ipc::common::ConfigCall *>(msg()) : nullptr;
  }
  const TagCall *msg_as_TagCall() const {
    return msg_type() == Calls::TagCall ? static_cast<const TagCall *>(msg()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyCalls(verifier, msg(), msg_type()) &&
           verifier.EndTable();
  }
  CallT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CallT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Call> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const nfcdoorz::ipc::common::ConfigCall *Call::msg_as<nfcdoorz::ipc::common::ConfigCall>() const {
  return msg_as_nfcdoorz_ipc_common_ConfigCall();
}

template<> inline const TagCall *Call::msg_as<TagCall>() const {
  return msg_as_TagCall();
}

struct CallBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Call::VT_ID, id, 0);
  }
  void add_msg_type(Calls msg_type) {
    fbb_.AddElement<uint8_t>(Call::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(Call::VT_MSG, msg);
  }
  explicit CallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallBuilder &operator=(const CallBuilder &);
  flatbuffers::Offset<Call> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Call>(end);
    return o;
  }
};

inline flatbuffers::Offset<Call> CreateCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    Calls msg_type = Calls::NONE,
    flatbuffers::Offset<void> msg = 0) {
  CallBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

flatbuffers::Offset<Call> CreateCall(flatbuffers::FlatBufferBuilder &_fbb, const CallT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReplyT : public flatbuffers::NativeTable {
  typedef Reply TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.ReplyT";
  }
  uint64_t id;
  RepliesUnion msg;
  EventsUnion event;
  ReplyT()
      : id(0) {
  }
};

struct Reply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReplyT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReplyTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.Reply";
  }
  enum {
    VT_ID = 4,
    VT_MSG_TYPE = 6,
    VT_MSG = 8,
    VT_EVENT_TYPE = 10,
    VT_EVENT = 12
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  Replies msg_type() const {
    return static_cast<Replies>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const nfcdoorz::ipc::common::ConfigReply *msg_as_nfcdoorz_ipc_common_ConfigReply() const {
    return msg_type() == Replies::nfcdoorz_ipc_common_ConfigReply ? static_cast<const nfcdoorz::ipc::common::ConfigReply *>(msg()) : nullptr;
  }
  const TagReply *msg_as_TagReply() const {
    return msg_type() == Replies::TagReply ? static_cast<const TagReply *>(msg()) : nullptr;
  }
  Events event_type() const {
    return static_cast<Events>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  template<typename T> const T *event_as() const;
  const RandomEvent *event_as_RandomEvent() const {
    return event_type() == Events::RandomEvent ? static_cast<const RandomEvent *>(event()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyReplies(verifier, msg(), msg_type()) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE) &&
           VerifyOffset(verifier, VT_EVENT) &&
           VerifyEvents(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
  ReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const nfcdoorz::ipc::common::ConfigReply *Reply::msg_as<nfcdoorz::ipc::common::ConfigReply>() const {
  return msg_as_nfcdoorz_ipc_common_ConfigReply();
}

template<> inline const TagReply *Reply::msg_as<TagReply>() const {
  return msg_as_TagReply();
}

template<> inline const RandomEvent *Reply::event_as<RandomEvent>() const {
  return event_as_RandomEvent();
}

struct ReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Reply::VT_ID, id, 0);
  }
  void add_msg_type(Replies msg_type) {
    fbb_.AddElement<uint8_t>(Reply::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(Reply::VT_MSG, msg);
  }
  void add_event_type(Events event_type) {
    fbb_.AddElement<uint8_t>(Reply::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(flatbuffers::Offset<void> event) {
    fbb_.AddOffset(Reply::VT_EVENT, event);
  }
  explicit ReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReplyBuilder &operator=(const ReplyBuilder &);
  flatbuffers::Offset<Reply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reply>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply> CreateReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    Replies msg_type = Replies::NONE,
    flatbuffers::Offset<void> msg = 0,
    Events event_type = Events::NONE,
    flatbuffers::Offset<void> event = 0) {
  ReplyBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_event(event);
  builder_.add_msg(msg);
  builder_.add_event_type(event_type);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

flatbuffers::Offset<Reply> CreateReply(flatbuffers::FlatBufferBuilder &_fbb, const ReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ServerT : public flatbuffers::NativeTable {
  typedef Server TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.ServerT";
  }
  std::unique_ptr<CallT> call;
  std::unique_ptr<ReplyT> reply;
  ServerT() {
  }
};

struct Server FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ServerTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "nfcdoorz.ipc.auth.Server";
  }
  enum {
    VT_CALL = 4,
    VT_REPLY = 6
  };
  const Call *call() const {
    return GetPointer<const Call *>(VT_CALL);
  }
  const Reply *reply() const {
    return GetPointer<const Reply *>(VT_REPLY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CALL) &&
           verifier.VerifyTable(call()) &&
           VerifyOffset(verifier, VT_REPLY) &&
           verifier.VerifyTable(reply()) &&
           verifier.EndTable();
  }
  ServerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ServerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Server> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ServerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_call(flatbuffers::Offset<Call> call) {
    fbb_.AddOffset(Server::VT_CALL, call);
  }
  void add_reply(flatbuffers::Offset<Reply> reply) {
    fbb_.AddOffset(Server::VT_REPLY, reply);
  }
  explicit ServerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerBuilder &operator=(const ServerBuilder &);
  flatbuffers::Offset<Server> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Server>(end);
    return o;
  }
};

inline flatbuffers::Offset<Server> CreateServer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Call> call = 0,
    flatbuffers::Offset<Reply> reply = 0) {
  ServerBuilder builder_(_fbb);
  builder_.add_reply(reply);
  builder_.add_call(call);
  return builder_.Finish();
}

flatbuffers::Offset<Server> CreateServer(flatbuffers::FlatBufferBuilder &_fbb, const ServerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline PingT *Ping::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PingT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Ping::UnPackTo(PingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Ping> Ping::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePing(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Ping> CreatePing(flatbuffers::FlatBufferBuilder &_fbb, const PingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return nfcdoorz::ipc::auth::CreatePing(
      _fbb);
}

inline AppIDT *AppID::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AppIDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AppID::UnPackTo(AppIDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = a(); _o->a = _e; };
  { auto _e = b(); _o->b = _e; };
  { auto _e = c(); _o->c = _e; };
}

inline flatbuffers::Offset<AppID> AppID::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AppIDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAppID(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AppID> CreateAppID(flatbuffers::FlatBufferBuilder &_fbb, const AppIDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AppIDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _a = _o->a;
  auto _b = _o->b;
  auto _c = _o->c;
  return nfcdoorz::ipc::auth::CreateAppID(
      _fbb,
      _a,
      _b,
      _c);
}

inline KeyT *Key::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new KeyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Key::UnPackTo(KeyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = _e->str(); };
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Key> Key::Pack(flatbuffers::FlatBufferBuilder &_fbb, const KeyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateKey(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Key> CreateKey(flatbuffers::FlatBufferBuilder &_fbb, const KeyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const KeyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type.empty() ? 0 : _fbb.CreateString(_o->type);
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return nfcdoorz::ipc::auth::CreateKey(
      _fbb,
      _type,
      _data);
}

inline AuthAppT *AuthApp::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AuthAppT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AuthApp::UnPackTo(AuthAppT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = aid(); if (_e) _o->aid = std::unique_ptr<AppIDT>(_e->UnPack(_resolver)); };
  { auto _e = key(); if (_e) _o->key = std::unique_ptr<KeyT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<AuthApp> AuthApp::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthAppT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAuthApp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AuthApp> CreateAuthApp(flatbuffers::FlatBufferBuilder &_fbb, const AuthAppT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AuthAppT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _aid = _o->aid ? CreateAppID(_fbb, _o->aid.get(), _rehasher) : 0;
  auto _key = _o->key ? CreateKey(_fbb, _o->key.get(), _rehasher) : 0;
  return nfcdoorz::ipc::auth::CreateAuthApp(
      _fbb,
      _aid,
      _key);
}

inline GetUIDT *GetUID::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GetUIDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GetUID::UnPackTo(GetUIDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GetUID> GetUID::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GetUIDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetUID(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GetUID> CreateGetUID(flatbuffers::FlatBufferBuilder &_fbb, const GetUIDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GetUIDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return nfcdoorz::ipc::auth::CreateGetUID(
      _fbb);
}

inline TagPresentT *TagPresent::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TagPresentT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TagPresent::UnPackTo(TagPresentT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = present(); _o->present = _e; };
}

inline flatbuffers::Offset<TagPresent> TagPresent::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TagPresentT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTagPresent(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TagPresent> CreateTagPresent(flatbuffers::FlatBufferBuilder &_fbb, const TagPresentT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TagPresentT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _present = _o->present;
  return nfcdoorz::ipc::auth::CreateTagPresent(
      _fbb,
      _present);
}

inline TagUIDResultT *TagUIDResult::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TagUIDResultT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TagUIDResult::UnPackTo(TagUIDResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uid(); if (_e) { _o->uid.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->uid[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<TagUIDResult> TagUIDResult::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TagUIDResultT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTagUIDResult(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TagUIDResult> CreateTagUIDResult(flatbuffers::FlatBufferBuilder &_fbb, const TagUIDResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TagUIDResultT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uid = _o->uid.size() ? _fbb.CreateVector(_o->uid) : 0;
  return nfcdoorz::ipc::auth::CreateTagUIDResult(
      _fbb,
      _uid);
}

inline ResultT *Result::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ResultT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Result::UnPackTo(ResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ok(); _o->ok = _e; };
  { auto _e = data_type(); _o->data.type = _e; };
  { auto _e = data(); if (_e) _o->data.value = ResultDataUnion::UnPack(_e, data_type(), _resolver); };
}

inline flatbuffers::Offset<Result> Result::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResultT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResult(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Result> CreateResult(flatbuffers::FlatBufferBuilder &_fbb, const ResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResultT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ok = _o->ok;
  auto _data_type = _o->data.type;
  auto _data = _o->data.Pack(_fbb);
  return nfcdoorz::ipc::auth::CreateResult(
      _fbb,
      _ok,
      _data_type,
      _data);
}

inline TagThingT *TagThing::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TagThingT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TagThing::UnPackTo(TagThingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TagThing> TagThing::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TagThingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTagThing(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TagThing> CreateTagThing(flatbuffers::FlatBufferBuilder &_fbb, const TagThingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TagThingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return nfcdoorz::ipc::auth::CreateTagThing(
      _fbb);
}

inline TagCallT *TagCall::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TagCallT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TagCall::UnPackTo(TagCallT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uid(); if (_e) { _o->uid.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->uid[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<TagCall> TagCall::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TagCallT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTagCall(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TagCall> CreateTagCall(flatbuffers::FlatBufferBuilder &_fbb, const TagCallT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TagCallT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uid = _o->uid.size() ? _fbb.CreateVector(_o->uid) : 0;
  return nfcdoorz::ipc::auth::CreateTagCall(
      _fbb,
      _uid);
}

inline TagReplyT *TagReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TagReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TagReply::UnPackTo(TagReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TagReply> TagReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TagReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTagReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TagReply> CreateTagReply(flatbuffers::FlatBufferBuilder &_fbb, const TagReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TagReplyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return nfcdoorz::ipc::auth::CreateTagReply(
      _fbb);
}

inline RandomEventT *RandomEvent::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RandomEventT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RandomEvent::UnPackTo(RandomEventT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<RandomEvent> RandomEvent::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RandomEventT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRandomEvent(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RandomEvent> CreateRandomEvent(flatbuffers::FlatBufferBuilder &_fbb, const RandomEventT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RandomEventT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return nfcdoorz::ipc::auth::CreateRandomEvent(
      _fbb);
}

inline CallT *Call::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CallT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Call::UnPackTo(CallT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = msg_type(); _o->msg.type = _e; };
  { auto _e = msg(); if (_e) _o->msg.value = CallsUnion::UnPack(_e, msg_type(), _resolver); };
}

inline flatbuffers::Offset<Call> Call::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCall(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Call> CreateCall(flatbuffers::FlatBufferBuilder &_fbb, const CallT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CallT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _msg_type = _o->msg.type;
  auto _msg = _o->msg.Pack(_fbb);
  return nfcdoorz::ipc::auth::CreateCall(
      _fbb,
      _id,
      _msg_type,
      _msg);
}

inline ReplyT *Reply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply::UnPackTo(ReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = msg_type(); _o->msg.type = _e; };
  { auto _e = msg(); if (_e) _o->msg.value = RepliesUnion::UnPack(_e, msg_type(), _resolver); };
  { auto _e = event_type(); _o->event.type = _e; };
  { auto _e = event(); if (_e) _o->event.value = EventsUnion::UnPack(_e, event_type(), _resolver); };
}

inline flatbuffers::Offset<Reply> Reply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply> CreateReply(flatbuffers::FlatBufferBuilder &_fbb, const ReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReplyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _msg_type = _o->msg.type;
  auto _msg = _o->msg.Pack(_fbb);
  auto _event_type = _o->event.type;
  auto _event = _o->event.Pack(_fbb);
  return nfcdoorz::ipc::auth::CreateReply(
      _fbb,
      _id,
      _msg_type,
      _msg,
      _event_type,
      _event);
}

inline ServerT *Server::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ServerT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Server::UnPackTo(ServerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = call(); if (_e) _o->call = std::unique_ptr<CallT>(_e->UnPack(_resolver)); };
  { auto _e = reply(); if (_e) _o->reply = std::unique_ptr<ReplyT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Server> Server::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateServer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Server> CreateServer(flatbuffers::FlatBufferBuilder &_fbb, const ServerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ServerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _call = _o->call ? CreateCall(_fbb, _o->call.get(), _rehasher) : 0;
  auto _reply = _o->reply ? CreateReply(_fbb, _o->reply.get(), _rehasher) : 0;
  return nfcdoorz::ipc::auth::CreateServer(
      _fbb,
      _call,
      _reply);
}

inline bool VerifyResultData(flatbuffers::Verifier &verifier, const void *obj, ResultData type) {
  switch (type) {
    case ResultData::NONE: {
      return true;
    }
    case ResultData::TagUIDResult: {
      auto ptr = reinterpret_cast<const TagUIDResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyResultDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResultData(
        verifier,  values->Get(i), types->GetEnum<ResultData>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ResultDataUnion::UnPack(const void *obj, ResultData type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case ResultData::TagUIDResult: {
      auto ptr = reinterpret_cast<const TagUIDResult *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ResultDataUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case ResultData::TagUIDResult: {
      auto ptr = reinterpret_cast<const TagUIDResultT *>(value);
      return CreateTagUIDResult(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ResultDataUnion::ResultDataUnion(const ResultDataUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case ResultData::TagUIDResult: {
      value = new TagUIDResultT(*reinterpret_cast<TagUIDResultT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ResultDataUnion::Reset() {
  switch (type) {
    case ResultData::TagUIDResult: {
      auto ptr = reinterpret_cast<TagUIDResultT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ResultData::NONE;
}

inline bool VerifyCalls(flatbuffers::Verifier &verifier, const void *obj, Calls type) {
  switch (type) {
    case Calls::NONE: {
      return true;
    }
    case Calls::nfcdoorz_ipc_common_ConfigCall: {
      auto ptr = reinterpret_cast<const nfcdoorz::ipc::common::ConfigCall *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Calls::TagCall: {
      auto ptr = reinterpret_cast<const TagCall *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyCallsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCalls(
        verifier,  values->Get(i), types->GetEnum<Calls>(i))) {
      return false;
    }
  }
  return true;
}

inline void *CallsUnion::UnPack(const void *obj, Calls type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Calls::nfcdoorz_ipc_common_ConfigCall: {
      auto ptr = reinterpret_cast<const nfcdoorz::ipc::common::ConfigCall *>(obj);
      return ptr->UnPack(resolver);
    }
    case Calls::TagCall: {
      auto ptr = reinterpret_cast<const TagCall *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> CallsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Calls::nfcdoorz_ipc_common_ConfigCall: {
      auto ptr = reinterpret_cast<const nfcdoorz::ipc::common::ConfigCallT *>(value);
      return CreateConfigCall(_fbb, ptr, _rehasher).Union();
    }
    case Calls::TagCall: {
      auto ptr = reinterpret_cast<const TagCallT *>(value);
      return CreateTagCall(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline CallsUnion::CallsUnion(const CallsUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case Calls::nfcdoorz_ipc_common_ConfigCall: {
      value = new nfcdoorz::ipc::common::ConfigCallT(*reinterpret_cast<nfcdoorz::ipc::common::ConfigCallT *>(u.value));
      break;
    }
    case Calls::TagCall: {
      value = new TagCallT(*reinterpret_cast<TagCallT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void CallsUnion::Reset() {
  switch (type) {
    case Calls::nfcdoorz_ipc_common_ConfigCall: {
      auto ptr = reinterpret_cast<nfcdoorz::ipc::common::ConfigCallT *>(value);
      delete ptr;
      break;
    }
    case Calls::TagCall: {
      auto ptr = reinterpret_cast<TagCallT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Calls::NONE;
}

inline bool VerifyReplies(flatbuffers::Verifier &verifier, const void *obj, Replies type) {
  switch (type) {
    case Replies::NONE: {
      return true;
    }
    case Replies::nfcdoorz_ipc_common_ConfigReply: {
      auto ptr = reinterpret_cast<const nfcdoorz::ipc::common::ConfigReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Replies::TagReply: {
      auto ptr = reinterpret_cast<const TagReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyRepliesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyReplies(
        verifier,  values->Get(i), types->GetEnum<Replies>(i))) {
      return false;
    }
  }
  return true;
}

inline void *RepliesUnion::UnPack(const void *obj, Replies type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Replies::nfcdoorz_ipc_common_ConfigReply: {
      auto ptr = reinterpret_cast<const nfcdoorz::ipc::common::ConfigReply *>(obj);
      return ptr->UnPack(resolver);
    }
    case Replies::TagReply: {
      auto ptr = reinterpret_cast<const TagReply *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> RepliesUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Replies::nfcdoorz_ipc_common_ConfigReply: {
      auto ptr = reinterpret_cast<const nfcdoorz::ipc::common::ConfigReplyT *>(value);
      return CreateConfigReply(_fbb, ptr, _rehasher).Union();
    }
    case Replies::TagReply: {
      auto ptr = reinterpret_cast<const TagReplyT *>(value);
      return CreateTagReply(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline RepliesUnion::RepliesUnion(const RepliesUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case Replies::nfcdoorz_ipc_common_ConfigReply: {
      value = new nfcdoorz::ipc::common::ConfigReplyT(*reinterpret_cast<nfcdoorz::ipc::common::ConfigReplyT *>(u.value));
      break;
    }
    case Replies::TagReply: {
      value = new TagReplyT(*reinterpret_cast<TagReplyT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void RepliesUnion::Reset() {
  switch (type) {
    case Replies::nfcdoorz_ipc_common_ConfigReply: {
      auto ptr = reinterpret_cast<nfcdoorz::ipc::common::ConfigReplyT *>(value);
      delete ptr;
      break;
    }
    case Replies::TagReply: {
      auto ptr = reinterpret_cast<TagReplyT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Replies::NONE;
}

inline bool VerifyEvents(flatbuffers::Verifier &verifier, const void *obj, Events type) {
  switch (type) {
    case Events::NONE: {
      return true;
    }
    case Events::RandomEvent: {
      auto ptr = reinterpret_cast<const RandomEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEvents(
        verifier,  values->Get(i), types->GetEnum<Events>(i))) {
      return false;
    }
  }
  return true;
}

inline void *EventsUnion::UnPack(const void *obj, Events type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Events::RandomEvent: {
      auto ptr = reinterpret_cast<const RandomEvent *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> EventsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Events::RandomEvent: {
      auto ptr = reinterpret_cast<const RandomEventT *>(value);
      return CreateRandomEvent(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline EventsUnion::EventsUnion(const EventsUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case Events::RandomEvent: {
      value = new RandomEventT(*reinterpret_cast<RandomEventT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void EventsUnion::Reset() {
  switch (type) {
    case Events::RandomEvent: {
      auto ptr = reinterpret_cast<RandomEventT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Events::NONE;
}

inline const flatbuffers::TypeTable *ResultDataTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TagUIDResultTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "TagUIDResult"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CallsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    nfcdoorz::ipc::common::ConfigCallTypeTable,
    TagCallTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "nfcdoorz_ipc_common_ConfigCall",
    "TagCall"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RepliesTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    nfcdoorz::ipc::common::ConfigReplyTypeTable,
    TagReplyTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "nfcdoorz_ipc_common_ConfigReply",
    "TagReply"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EventsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    RandomEventTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "RandomEvent"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PingTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AppIDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "a",
    "b",
    "c"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *KeyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const char * const names[] = {
    "type",
    "data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AuthAppTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AppIDTypeTable,
    KeyTypeTable
  };
  static const char * const names[] = {
    "aid",
    "key"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GetUIDTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TagPresentTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "present"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TagUIDResultTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const char * const names[] = {
    "uid"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResultTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ResultDataTypeTable
  };
  static const char * const names[] = {
    "ok",
    "data_type",
    "data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TagThingTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TagCallTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const char * const names[] = {
    "uid"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TagReplyTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RandomEventTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CallTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    CallsTypeTable
  };
  static const char * const names[] = {
    "id",
    "msg_type",
    "msg"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReplyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_UTYPE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    RepliesTypeTable,
    EventsTypeTable
  };
  static const char * const names[] = {
    "id",
    "msg_type",
    "msg",
    "event_type",
    "event"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ServerTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    CallTypeTable,
    ReplyTypeTable
  };
  static const char * const names[] = {
    "call",
    "reply"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

}  // namespace auth
}  // namespace ipc
}  // namespace nfcdoorz

#endif  // FLATBUFFERS_GENERATED_IPCAUTH_NFCDOORZ_IPC_AUTH_H_
